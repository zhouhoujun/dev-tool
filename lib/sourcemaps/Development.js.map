{"version":3,"sources":["Development.ts"],"names":["_","require","minimist","loaderFactory_1","development_core_1","Context_1","chalk","events_1","Development","_super","dirname","config","_this","call","this","evnets","each","keys","key","on","__extends","create","gulp","setting","runWay","factory","RunWay","sequence","option","isArray","tasks","isUndefined","contextFactory","cfg","parent","ctx","Context","add","devtool","setup","prototype","run","env","setupTasks","then","seq","tseq","task","split","gbctx","getContext","emit","parallel","runSequence","flattenSequence","catch","err","console","error","process","exit","root","help","log","grey","printHelp","loadTasks","tsq","setupTask","callback","options","argv","slice","string","default","NODE_ENV","startTask","Promise","reject","start","globalctx","taskOptions","all","map","optask","oper","loader","createLoader","loadContext","isString","load","loadAssertTasks","loadSubTask","tks","rst","tasklist","sq","idx","opt","ordertask","sortOrder","itm","order","t","push","filter","it","zipSequence","tk","assertsTask","subGroupTask","resolve","toSequence","tsqs","runTasks","addToSequence","optask_1","subopt","subOrder","to","subTaskOrder","isNumber","assertsRunWay","subTaskRunWay","name","subTaskName","subseq","taskname","runway","taskName","assertOrder","assertsOrder","asserts","tasks_1","op","sr","src","pipes","isFunction","length","some","watch","isNull","getSrc","Operation","loaderFactory","LoaderFactory","p","EventEmitter","exports"],"mappings":"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","file":"../Development.js","sourcesContent":["import * as _ from 'lodash';\r\nimport { Gulp, TaskCallback } from 'gulp';\r\n\r\nimport * as minimist from 'minimist';\r\nimport { ITaskLoader } from './ITaskLoader';\r\nimport { LoaderFactory } from './loaderFactory';\r\nimport { Operation, ITaskConfig, Src, toSequence, runSequence, zipSequence, sortOrder, currentOperation, flattenSequence, ITaskContext, ITaskInfo, ITask, IEnvOption, IDynamicTaskOption, RunWay } from 'development-core';\r\nimport { TaskOption, ITaskOption, IAssertOption } from './TaskOption';\r\nimport { IContext } from './IContext';\r\nimport { Context } from './Context';\r\nimport { DevelopConfig } from './DevelopConfig';\r\nimport * as chalk from 'chalk';\r\nimport { EventEmitter } from 'events';\r\n\r\ninterface TaskSeq {\r\n    opt: ITaskOption,\r\n    seq: Src[]\r\n}\r\n\r\nexport class Development extends EventEmitter {\r\n\r\n    /**\r\n     * create development tool.\r\n     * \r\n     * @static\r\n     * @param {Gulp} gulp\r\n     * @param {string} dirname\r\n     * @param {(DevelopConfig | Array<ITaskOption | IAssertOption | IDynamicTaskOption>)} setting\r\n     * @param {any} [runWay=RunWay.sequence]\r\n     * @returns {Development}\r\n     * \r\n     * @memberOf Development\r\n     */\r\n    static create(gulp: Gulp, dirname: string, setting: DevelopConfig | Array<ITaskOption | IAssertOption | IDynamicTaskOption>, runWay = RunWay.sequence, factory?: (cfg: ITaskConfig, parent?: ITaskContext) => ITaskContext): Development {\r\n        let option = _.isArray(setting) ? { tasks: setting, runWay: runWay } : setting;\r\n        if (!_.isUndefined(option.runWay)) {\r\n            option.runWay = runWay;\r\n        }\r\n        option.contextFactory = factory || ((cfg, parent?) => {\r\n            let ctx = new Context(cfg, parent);\r\n            if (parent && parent.add) {\r\n                (<IContext>parent).add(ctx);\r\n            }\r\n            return ctx;\r\n        })\r\n\r\n        let devtool = new Development(dirname, option);\r\n        devtool.setup(gulp);\r\n        return devtool;\r\n    }\r\n\r\n    /**\r\n     * Creates an instance of Development.\r\n     * \r\n     * @param {string} dirname\r\n     * @param {DevelopConfig} config\r\n     * \r\n     * @memberOf Development\r\n     */\r\n    public constructor(private dirname: string, protected config: DevelopConfig) {\r\n        super();\r\n        if (config.evnets) {\r\n            _.each(_.keys(config.evnets), key => {\r\n                this.on(key, config.evnets[key]);\r\n            });\r\n        }\r\n    }\r\n\r\n    /**\r\n     * run task.\r\n     * \r\n     * @param {Gulp} gulp\r\n     * @param {IEnvOption} env\r\n     * @returns {Promise<any>}\r\n     * \r\n     * @memberOf Development\r\n     */\r\n    run(gulp: Gulp, env: IEnvOption): Promise<any> {\r\n        return this.setupTasks(gulp, env)\r\n            .then(seq => {\r\n                let tseq = env.task ? env.task.split(',') : seq;\r\n                let gbctx = this.getContext(env);\r\n                this.emit('beforRun', tseq, gbctx);\r\n                if (this.config.runWay === RunWay.parallel) {\r\n                    return runSequence(gulp, [flattenSequence(gulp, tseq, gbctx)]);\r\n                } else {\r\n                    return runSequence(gulp, tseq);\r\n                }\r\n            })\r\n            .then(() => {\r\n                let gbctx = this.getContext(env);\r\n                this.emit('afterRun', gbctx);\r\n            })\r\n            .catch(err => {\r\n                console.error(err);\r\n                process.exit(1);\r\n            });\r\n    }\r\n\r\n    setupTasks(gulp: Gulp, env: IEnvOption): Promise<Src[]> {\r\n        if (!env.root) {\r\n            env.root = this.dirname;\r\n        }\r\n\r\n        if (env.help) {\r\n            console.log(chalk.grey('... main help  ...'));\r\n            this.printHelp(env.help);\r\n        }\r\n\r\n        let gbctx = this.getContext(env);\r\n        this.emit('beforSetup', gbctx);\r\n        return this.loadTasks(gulp, this.config.tasks, gbctx)\r\n            .then(tsq => {\r\n                this.emit('afterSetup', tsq, gbctx);\r\n                return tsq;\r\n            })\r\n            .catch(err => {\r\n                console.error(err);\r\n                process.exit(1);\r\n            });\r\n    }\r\n\r\n    setup(gulp: Gulp) {\r\n        let config = this.config;\r\n        config.setupTask = config.setupTask || 'build';\r\n        gulp.task(config.setupTask, (callback: TaskCallback) => {\r\n            var options: IEnvOption = minimist(process.argv.slice(2), {\r\n                string: 'env',\r\n                default: { env: process.env.NODE_ENV || 'development' }\r\n            });\r\n            return this.run(gulp, options);\r\n        });\r\n\r\n        config.startTask = config.startTask || 'start';\r\n        gulp.task(config.startTask, (callback: TaskCallback) => {\r\n            var options: IEnvOption = minimist(process.argv.slice(2), {\r\n                string: 'env',\r\n                default: { env: process.env.NODE_ENV || 'development' }\r\n            });\r\n            if (!options.task) {\r\n                return Promise.reject('start task can not empty!');\r\n            }\r\n            return this.run(gulp, options);\r\n        })\r\n\r\n        gulp.task('default', () => {\r\n            gulp.start(config.setupTask);\r\n        });\r\n    }\r\n\r\n    private globalctx: IContext;\r\n    getContext(env) {\r\n        if (!this.globalctx || this.globalctx.env !== env) {\r\n            let option = this.config.option || {};\r\n            this.globalctx = <IContext>this.config.contextFactory({\r\n                env: env,\r\n                option: option\r\n            });\r\n        }\r\n\r\n        return this.globalctx;\r\n    }\r\n\r\n\r\n    protected loadTasks(gulp: Gulp, taskOptions: TaskOption, parent: IContext): Promise<Src[]> {\r\n        let tasks = _.isArray(taskOptions) ? <ITaskOption[]>taskOptions : [<ITaskOption>taskOptions];\r\n        return Promise.all<Src[]>(\r\n            _.map(tasks, optask => {\r\n                if (optask.oper && (this.globalctx.oper & optask.oper) <= 0) {\r\n                    return [];\r\n                }\r\n                // optask.dist = optask.dist || 'dist';\r\n                // console.log(chalk.grey('begin load task via loader:'), optask.loader);\r\n                let loader = this.createLoader(optask, parent);\r\n\r\n                return loader.loadContext(parent.env)\r\n                    .then(ctx => {\r\n                        // console.log(chalk.green('task context loaded.'));\r\n                        if (ctx.env.help) {\r\n                            if (ctx.printHelp) {\r\n                                console.log(chalk.grey('...development default help...'));\r\n                                ctx.printHelp(_.isString(ctx.env.help) ? ctx.env.help : '');\r\n                            }\r\n                            return [];\r\n                        } else {\r\n                            return Promise.all([\r\n                                loader.load(ctx),\r\n                                this.loadAssertTasks(gulp, ctx),\r\n                                this.loadSubTask(gulp, ctx)\r\n                            ])\r\n                                .then(tks => {\r\n                                    // console.log(chalk.green('tasks loaded.'));\r\n                                    return this.setupTask(gulp, ctx, tks[0], tks[1], tks[2]);\r\n                                });\r\n                        }\r\n                    });\r\n            })\r\n        )\r\n            .then(tsq => {\r\n                let rst: Src[] = [];\r\n                let tasklist: TaskSeq[] = _.map(tsq, (sq, idx) => {\r\n                    return <TaskSeq>{\r\n                        opt: tasks[idx],\r\n                        seq: sq\r\n                    }\r\n                });\r\n\r\n                let ordertask = sortOrder(tasklist, itm => itm.opt.order, parent);\r\n                _.each(ordertask, (t, idx) => {\r\n                    if (_.isArray(t)) {\r\n                        rst.push(_.filter(_.map(t, it => zipSequence(gulp, it.seq, parent)), it => it));\r\n                    } else {\r\n                        let tk = zipSequence(gulp, t.seq, parent);\r\n                        if (tk) {\r\n                            rst.push(tk);\r\n                        }\r\n                    }\r\n                });\r\n                return rst;\r\n\r\n            });\r\n    }\r\n\r\n    protected setupTask(gulp: Gulp, ctx: ITaskContext, tasks: ITask[], assertsTask: ITaskInfo, subGroupTask: ITaskInfo): Promise<Src[]> {\r\n        return Promise.resolve(toSequence(gulp, tasks, ctx))\r\n            .then(tsqs => {\r\n                if (ctx.runTasks) {\r\n                    return ctx.runTasks(tsqs, assertsTask, subGroupTask);\r\n                }\r\n                // console.log(assertsTask);\r\n                ctx.addToSequence(tsqs, assertsTask);\r\n                ctx.addToSequence(tsqs, subGroupTask);\r\n\r\n                return tsqs;\r\n            });\r\n    }\r\n\r\n    /**\r\n     * load sub tasks as group task.\r\n     * \r\n     * @protected\r\n     * @param {Gulp} gulp\r\n     * @param {IContext} ctx\r\n     * @returns {Promise<ITaskInfo>}\r\n     * \r\n     * @memberOf Development\r\n     */\r\n    protected loadSubTask(gulp: Gulp, ctx: IContext): Promise<ITaskInfo> {\r\n        if (ctx.option['tasks']) {\r\n            let optask = <ITaskOption>ctx.option;\r\n            _.each(_.isArray(optask.tasks) ? optask.tasks : [optask.tasks], subopt => {\r\n                if (!subopt.order) {\r\n                    let subOrder = ctx.to(optask.subTaskOrder);\r\n                    if (!_.isNumber(subOrder) && subOrder) {\r\n                        optask.assertsRunWay = optask.assertsRunWay || subOrder.runWay;\r\n                    } else if (optask.subTaskRunWay) {\r\n                        subopt.order = { runWay: optask.subTaskRunWay };\r\n                    }\r\n                }\r\n                subopt.name = ctx.subTaskName(subopt.name);\r\n                // subopt.src = subopt.src || optask.src;\r\n                // subopt.dist = subopt.dist || optask.dist;\r\n            });\r\n            return this.loadTasks(gulp, optask.tasks, ctx)\r\n                .then(subseq => {\r\n                    let taskname;\r\n                    // if (optask.subTaskRunWay === RunWay.parallel) {\r\n                    //     taskname = [flattenSequence(gulp, subseq, ctx, (name, runway) => ctx.subTaskName(name, (runway === RunWay.sequence ? '-subs' : '-subp')))]\r\n                    // } else {\r\n                    taskname = zipSequence(gulp, subseq, ctx, (name, runway) => ctx.subTaskName(name, (runway === RunWay.sequence ? '-sub-seq' : '-sub-paral')));\r\n                    // }\r\n                    if (taskname) {\r\n                        return <ITaskInfo>{\r\n                            order: optask.subTaskOrder,\r\n                            taskName: taskname\r\n                        };\r\n                    } else {\r\n                        return null;\r\n                    }\r\n                });\r\n        } else {\r\n            return Promise.resolve(null);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * load asserts tasks.\r\n     * \r\n     * @protected\r\n     * @param {Gulp} gulp\r\n     * @param {ITaskContext} ctx\r\n     * @returns {Promise<Src>}\r\n     * \r\n     * @memberOf Development\r\n     */\r\n    protected loadAssertTasks(gulp: Gulp, ctx: IContext): Promise<ITaskInfo> {\r\n        let optask = <IAssertOption>ctx.option;\r\n\r\n        let assertOrder = ctx.to(optask.assertsOrder);\r\n        if (!_.isNumber(assertOrder) && assertOrder) {\r\n            optask.assertsRunWay = optask.assertsRunWay || assertOrder.runWay;\r\n        }\r\n        optask.assertsRunWay = optask.assertsRunWay || RunWay.parallel;\r\n\r\n        if (optask.asserts) {\r\n            let tasks: IAssertOption[] = [];\r\n            _.each(_.keys(optask.asserts), name => {\r\n                let op: IAssertOption;\r\n                let sr = optask.asserts[name];\r\n                if (_.isString(sr)) {\r\n                    op = <IAssertOption>{ src: sr };\r\n                } else if (_.isNumber(sr)) {\r\n                    // watch with Operation.autoWatch.\r\n                    op = <IAssertOption>{ loader: [{ oper: sr, name: name, pipes: [] }] };\r\n                } else if (_.isFunction(sr)) {\r\n                    op = { loader: sr };\r\n                } else if (_.isArray(sr)) {\r\n                    if (sr.length > 0) {\r\n                        if (!_.some(<string[]>sr, it => !_.isString(it))) {\r\n                            op = <IAssertOption>{ src: <string[]>sr };\r\n                        } else {\r\n                            op = <IAssertOption>{ loader: <IDynamicTaskOption[]>sr, watch: true };\r\n                        }\r\n                    }\r\n                } else {\r\n                    op = sr;\r\n                }\r\n\r\n                if (_.isNull(op) || _.isUndefined(op)) {\r\n                    return;\r\n                }\r\n                if (!op.loader) {\r\n                    op.loader = [{ name: name, pipes: [], watch: true }]\r\n                }\r\n                op.name = op.name || ctx.subTaskName(name);\r\n                op.src = op.src || (ctx.getSrc({ oper: Operation.default }) + '/**/*.' + name);\r\n                // op.dist = op.dist || ctx.getDist({ oper: Operation.build });\r\n                if (!op.order) {\r\n                    if (optask.assertsRunWay) {\r\n                        op.order = { runWay: optask.assertsRunWay };\r\n                    } else if (!_.isNumber(assertOrder)) {\r\n                        op.order = { runWay: assertOrder.runWay };\r\n                    }\r\n                }\r\n                tasks.push(op);\r\n            });\r\n\r\n            return this.loadTasks(gulp, tasks, ctx)\r\n                // .then(sq => {\r\n                //     return {\r\n                //         task: task,\r\n                //         sq: sq\r\n                //     }\r\n                // })\r\n\r\n                .then(tseq => {\r\n                    // asserts tasks run mutil.\r\n                    // let assertSeq = _.map(tseq, t => {\r\n                    //     return zipSequence(gulp, t.sq, ctx, (name, runway) => ctx.subTaskName(t.task.name, runway === RunWay.sequence ? '-asserts-seq' : '-assert-paral'));\r\n                    // });\r\n\r\n                    let taskname;\r\n                    // if (optask.assertsRunWay === RunWay.sequence) {\r\n                    //     taskname = assertSeq;\r\n                    // } else {\r\n                    taskname = zipSequence(gulp, tseq, ctx, (name, runway) => name + (runway === RunWay.sequence ? '-asserts-seq' : '-assert-paral'));\r\n                    // }\r\n\r\n                    return <ITaskInfo>{\r\n                        order: optask.assertsOrder,\r\n                        taskName: taskname\r\n                    }\r\n                });\r\n        } else {\r\n            return Promise.resolve(null);\r\n        }\r\n    }\r\n\r\n    protected createLoader(option: TaskOption, parent: IContext): ITaskLoader {\r\n        if (!_.isFunction(this.config.loaderFactory)) {\r\n            let factory = new LoaderFactory();\r\n            return factory.create(option, parent.env, (cfg, p) => {\r\n                return this.config.contextFactory(cfg, p || parent);\r\n            });\r\n        } else {\r\n            return this.config.loaderFactory(option, parent.env);\r\n        }\r\n    }\r\n\r\n\r\n    protected printHelp(help: boolean | string) {\r\n        if (help === 'en') {\r\n\r\n            console.log(`\r\n                /**\r\n                 * gulp [build] [--env production|development] [--context name] [--root path] [--watch] [--test] [--serve] [--release] [--task taskname]\r\n                 * @params\r\n                 *  --env  development or production;\r\n                 *  --context app setting\r\n                 *  --root path, set relative path of the development tool root.\r\n                 *  --watch  watch src file change or not. if changed will auto update to node service. \r\n                 *  --release release web app or not. if [--env production], default to release. \r\n                 *  --test  need auto load test file to node service.\r\n                 *  --deploy run deploy tasks to deploy project.  \r\n                 *  --serve start node web service or not.\r\n                 *  --task taskname  spruce task taskname\r\n                 **/`);\r\n\r\n        } else {\r\n\r\n            console.log(`\r\n                /**\r\n                 * gulp [build] [--env production|development] [--context name] [--root path] [--watch] [--test] [--serve] [--release] [--task taskname]\r\n                 * @params\r\n                 *  --env 发布环境 默认开发环境development;\r\n                 *  --context 设置配置文件;\r\n                 *  --root path, 设置编译环境相对路径\r\n                 *  --watch  是否需要动态监听文件变化\r\n                 *  --release 是否release编译, [--env production] 默认release \r\n                 *  --test  启动自动化测试\r\n                 *  --deploy 运行加载deploy tasks, 编译发布项目。  \r\n                 *  --serve  是否在开发模式下 开启node web服务\r\n                 *  --task taskname  运行单独任务taskname\r\n                 **/`);\r\n\r\n        }\r\n    }\r\n}\r\n"]}