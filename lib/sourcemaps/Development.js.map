{"version":3,"sources":["Development.ts"],"names":["_","require","minimist","LoaderFactory_1","development_core_1","Context_1","chalk","events_1","Development","_super","dirname","config","_this","call","this","evnets","each","keys","key","on","__extends","create","gulp","setting","runWay","factory","RunWay","sequence","option","isArray","tasks","isUndefined","contextFactory","cfg","parent","ctx","Context","add","devtool","setup","prototype","run","env","setupTasks","then","seq","tseq","task","split","gbctx","getContext","emit","parallel","runSequence","flattenSequence","catch","err","console","error","process","exit","root","help","log","grey","printHelp","loadTasks","tsq","setupTask","callback","options","argv","slice","string","default","NODE_ENV","startTask","Promise","reject","start","globalctx","all","map","optask","loader","createLoader","loadContext","green","isString","load","loadAssertTasks","loadSubTask","tks","rst","t","tk","zipSequence","push","assertsTask","subGroupTask","resolve","toSequence","tsqs","runTasks","addToSequence","optask_1","subopt","name","subTaskName","subseq","taskname","subTaskRunWay","runway","order","subTaskOrder","taskName","asserts","tasks_1","op","sr","src","pipes","watch","isNumber","oper","isFunction","length","first","isNull","getSrc","Operation","build","sq","assertSeq","assertsRunWay","assertsOrder","loaderFactory","LoaderFactory","p","EventEmitter","exports"],"mappings":"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","file":"../Development.js","sourcesContent":["import * as _ from 'lodash';\r\nimport { Gulp, TaskCallback } from 'gulp';\r\n\r\nimport * as minimist from 'minimist';\r\nimport { ITaskLoader } from './ITaskLoader';\r\nimport { LoaderFactory } from './LoaderFactory';\r\nimport { Operation, ITaskConfig, Src, toSequence, runSequence, bindingConfig, zipSequence, flattenSequence, ITaskContext, ITaskInfo, ITask, IEnvOption, IDynamicTaskOption, RunWay } from 'development-core';\r\nimport { TaskOption, ITaskOption, IAssertOption } from './TaskOption';\r\nimport { IContext } from './IContext';\r\nimport { Context } from './Context';\r\nimport { DevelopConfig } from './DevelopConfig';\r\nimport * as chalk from 'chalk';\r\nimport { EventEmitter } from 'events';\r\n\r\nexport class Development extends EventEmitter {\r\n\r\n    /**\r\n     * create development tool.\r\n     * \r\n     * @static\r\n     * @param {Gulp} gulp\r\n     * @param {string} dirname\r\n     * @param {(DevelopConfig | Array<ITaskOption | IAssertOption | IDynamicTaskOption>)} setting\r\n     * @param {any} [runWay=RunWay.sequence]\r\n     * @returns {Development}\r\n     * \r\n     * @memberOf Development\r\n     */\r\n    static create(gulp: Gulp, dirname: string, setting: DevelopConfig | Array<ITaskOption | IAssertOption | IDynamicTaskOption>, runWay = RunWay.sequence, factory?: (cfg: ITaskConfig, parent?: ITaskContext) => ITaskContext): Development {\r\n        let option = _.isArray(setting) ? { tasks: setting, runWay: runWay } : setting;\r\n        if (!_.isUndefined(option.runWay)) {\r\n            option.runWay = runWay;\r\n        }\r\n        option.contextFactory = factory || ((cfg, parent?) => {\r\n            let ctx = new Context(cfg, parent);\r\n            if (parent && parent.add) {\r\n                (<IContext>parent).add(ctx);\r\n            }\r\n            return ctx;\r\n        })\r\n\r\n        let devtool = new Development(dirname, option);\r\n        devtool.setup(gulp);\r\n        return devtool;\r\n    }\r\n\r\n    /**\r\n     * Creates an instance of Development.\r\n     * \r\n     * @param {string} dirname\r\n     * @param {DevelopConfig} config\r\n     * \r\n     * @memberOf Development\r\n     */\r\n    public constructor(private dirname: string, protected config: DevelopConfig) {\r\n        super();\r\n        if (config.evnets) {\r\n            _.each(_.keys(config.evnets), key => {\r\n                this.on(key, config.evnets[key]);\r\n            });\r\n        }\r\n    }\r\n\r\n    /**\r\n     * run task.\r\n     * \r\n     * @param {Gulp} gulp\r\n     * @param {IEnvOption} env\r\n     * @returns {Promise<any>}\r\n     * \r\n     * @memberOf Development\r\n     */\r\n    run(gulp: Gulp, env: IEnvOption): Promise<any> {\r\n        return this.setupTasks(gulp, env)\r\n            .then(seq => {\r\n                let tseq = env.task ? env.task.split(',') : seq;\r\n                let gbctx = this.getContext(env);\r\n                this.emit('beforRun', tseq, gbctx);\r\n                if (this.config.runWay === RunWay.parallel) {\r\n                    return runSequence(gulp, [flattenSequence(gulp, tseq, gbctx)]);\r\n                } else {\r\n                    return runSequence(gulp, tseq);\r\n                }\r\n            })\r\n            .then(() => {\r\n                let gbctx = this.getContext(env);\r\n                this.emit('afterRun', gbctx);\r\n            })\r\n            .catch(err => {\r\n                console.error(err);\r\n                process.exit(1);\r\n            });\r\n    }\r\n\r\n    setupTasks(gulp: Gulp, env: IEnvOption): Promise<Src[]> {\r\n        if (!env.root) {\r\n            env.root = this.dirname;\r\n        }\r\n\r\n        if (env.help) {\r\n            console.log(chalk.grey('... main help  ...'));\r\n            this.printHelp(env.help);\r\n        }\r\n\r\n        let gbctx = this.getContext(env);\r\n        this.emit('beforSetup', gbctx);\r\n        return this.loadTasks(gulp, this.config.tasks, gbctx)\r\n            .then(tsq => {\r\n                this.emit('afterSetup', tsq, gbctx);\r\n                return tsq;\r\n            })\r\n            .catch(err => {\r\n                console.error(err);\r\n                process.exit(1);\r\n            });\r\n    }\r\n\r\n    setup(gulp: Gulp) {\r\n        let config = this.config;\r\n        config.setupTask = config.setupTask || 'build';\r\n        gulp.task(config.setupTask, (callback: TaskCallback) => {\r\n            var options: IEnvOption = minimist(process.argv.slice(2), {\r\n                string: 'env',\r\n                default: { env: process.env.NODE_ENV || 'development' }\r\n            });\r\n            return this.run(gulp, options);\r\n        });\r\n\r\n        config.startTask = config.startTask || 'start';\r\n        gulp.task(config.startTask, (callback: TaskCallback) => {\r\n            var options: IEnvOption = minimist(process.argv.slice(2), {\r\n                string: 'env',\r\n                default: { env: process.env.NODE_ENV || 'development' }\r\n            });\r\n            if (!options.task) {\r\n                return Promise.reject('start task can not empty!');\r\n            }\r\n            return this.run(gulp, options);\r\n        })\r\n\r\n        gulp.task('default', () => {\r\n            gulp.start(config.setupTask);\r\n        });\r\n    }\r\n\r\n    private globalctx: IContext;\r\n    getContext(env) {\r\n        if (!this.globalctx || this.globalctx.env !== env) {\r\n            let option = this.config.option || {};\r\n            this.globalctx = <IContext>this.config.contextFactory({\r\n                env: env,\r\n                option: option\r\n            });\r\n        }\r\n\r\n        return this.globalctx;\r\n    }\r\n\r\n\r\n    protected loadTasks(gulp: Gulp, tasks: TaskOption, parent: IContext): Promise<Src[]> {\r\n        return Promise.all<Src[]>(\r\n            _.map(_.isArray(tasks) ? <ITaskOption[]>tasks : [<ITaskOption>tasks], optask => {\r\n                // optask.dist = optask.dist || 'dist';\r\n                // console.log(chalk.grey('begin load task via loader:'), optask.loader);\r\n                let loader = this.createLoader(optask, parent);\r\n\r\n                return loader.loadContext(parent.env)\r\n                    .then(ctx => {\r\n                        console.log(chalk.green('task context loaded.'));\r\n                        if (ctx.env.help) {\r\n                            if (ctx.printHelp) {\r\n                                console.log(chalk.grey('...development default help...'));\r\n                                ctx.printHelp(_.isString(ctx.env.help) ? ctx.env.help : '');\r\n                            }\r\n                            return [];\r\n                        } else {\r\n                            return Promise.all([\r\n                                loader.load(ctx),\r\n                                this.loadAssertTasks(gulp, ctx),\r\n                                this.loadSubTask(gulp, ctx)\r\n                            ])\r\n                                .then(tks => {\r\n                                    console.log(chalk.green('tasks loaded.'));\r\n                                    return this.setupTask(gulp, ctx, tks[0], tks[1], tks[2]);\r\n                                });\r\n                        }\r\n                    });\r\n            })\r\n        )\r\n            .then(tsq => {\r\n                let rst: Src[] = [];\r\n                _.each(tsq, t => {\r\n                    let tk = zipSequence(gulp, t, parent);\r\n                    if (tk) {\r\n                        rst.push(tk);\r\n                    }\r\n                });\r\n                return rst;\r\n\r\n            });\r\n    }\r\n\r\n    protected setupTask(gulp: Gulp, ctx: ITaskContext, tasks: ITask[], assertsTask: ITaskInfo, subGroupTask: ITaskInfo): Promise<Src[]> {\r\n        return Promise.resolve(toSequence(gulp, tasks, ctx))\r\n            .then(tsqs => {\r\n                if (ctx.runTasks) {\r\n                    return ctx.runTasks(tsqs, assertsTask, subGroupTask);\r\n                }\r\n                // console.log(assertsTask);\r\n                ctx.addToSequence(tsqs, assertsTask);\r\n                ctx.addToSequence(tsqs, subGroupTask);\r\n\r\n                return tsqs;\r\n            });\r\n    }\r\n\r\n    /**\r\n     * load sub tasks as group task.\r\n     * \r\n     * @protected\r\n     * @param {Gulp} gulp\r\n     * @param {IContext} ctx\r\n     * @returns {Promise<ITaskInfo>}\r\n     * \r\n     * @memberOf Development\r\n     */\r\n    protected loadSubTask(gulp: Gulp, ctx: IContext): Promise<ITaskInfo> {\r\n        if (ctx.option['tasks']) {\r\n            let optask = <ITaskOption>ctx.option;\r\n            _.each(_.isArray(optask.tasks) ? optask.tasks : [optask.tasks], subopt => {\r\n                subopt.name = ctx.subTaskName(subopt.name);\r\n                // subopt.src = subopt.src || optask.src;\r\n                // subopt.dist = subopt.dist || optask.dist;\r\n            });\r\n            return this.loadTasks(gulp, optask.tasks, ctx)\r\n                .then(subseq => {\r\n                    let taskname;\r\n                    if (optask.subTaskRunWay === RunWay.parallel) {\r\n                        taskname = [flattenSequence(gulp, subseq, ctx, (name, runway) => ctx.subTaskName(name, (runway === RunWay.sequence ? '-subs' : '-subp')))]\r\n                    } else {\r\n                        taskname = zipSequence(gulp, subseq, ctx, (name, runway) => ctx.subTaskName(name, (runway === RunWay.sequence ? '-subs' : '-subp')));\r\n                    }\r\n                    if (taskname) {\r\n                        return <ITaskInfo>{\r\n                            order: optask.subTaskOrder,\r\n                            taskName: taskname\r\n                        };\r\n                    } else {\r\n                        return null;\r\n                    }\r\n                });\r\n        } else {\r\n            return Promise.resolve(null);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * load asserts tasks.\r\n     * \r\n     * @protected\r\n     * @param {Gulp} gulp\r\n     * @param {ITaskContext} ctx\r\n     * @returns {Promise<Src>}\r\n     * \r\n     * @memberOf Development\r\n     */\r\n    protected loadAssertTasks(gulp: Gulp, ctx: IContext): Promise<ITaskInfo> {\r\n        let optask = <IAssertOption>ctx.option;\r\n        if (optask.asserts) {\r\n            let tasks: IAssertOption[] = [];\r\n            _.each(_.keys(optask.asserts), name => {\r\n                let op: IAssertOption;\r\n                let sr = optask.asserts[name];\r\n                if (_.isString(sr)) {\r\n                    op = <IAssertOption>{ src: sr, loader: [{ name: name, pipes: [], watch: true }] };\r\n                } else if (_.isNumber(sr)) {\r\n                    // watch with Operation.autoWatch.\r\n                    op = <IAssertOption>{ loader: [{ oper: sr, name: name, pipes: [] }] };\r\n                } else if (_.isFunction(sr)) {\r\n                    op = { loader: sr };\r\n                } else if (_.isArray(sr)) {\r\n                    if (sr.length > 0) {\r\n                        if (_.isString(_.first(<string[]>sr))) {\r\n                            op = <IAssertOption>{ src: <string[]>sr, loader: [{ name: name, pipes: [], watch: true }] };\r\n                        } else {\r\n                            op = <IAssertOption>{ loader: <IDynamicTaskOption[]>sr, watch: true };\r\n                        }\r\n                    }\r\n                } else {\r\n                    op = sr;\r\n                }\r\n\r\n                if (_.isNull(op) || _.isUndefined(op)) {\r\n                    return;\r\n                }\r\n                op.name = op.name || ctx.subTaskName(name);\r\n                op.src = op.src || (ctx.getSrc({ oper: Operation.build }) + '/**/*.' + name);\r\n                // op.dist = op.dist || ctx.getDist({ oper: Operation.build });\r\n                tasks.push(op);\r\n            });\r\n\r\n            return Promise.all(_.map(tasks, task => {\r\n                return this.loadTasks(gulp, <ITaskOption>task, ctx)\r\n                    .then(sq => {\r\n                        return {\r\n                            task: task,\r\n                            sq: sq\r\n                        }\r\n                    });\r\n            }))\r\n                .then(tseq => {\r\n                    // asserts tasks run mutil.\r\n                    let assertSeq = _.map(tseq, t => {\r\n                        return zipSequence(gulp, t.sq, ctx, (name, runway) => ctx.subTaskName(t.task.name, runway === RunWay.sequence ? '-asserts' : '-assertp')); // ctx.subTaskName(name + (runway === RunWay.sequence ? '-assert-seq' : '-assert-par')));\r\n                    });\r\n\r\n                    let taskname;\r\n                    if (optask.assertsRunWay === RunWay.sequence) {\r\n                        taskname = assertSeq;\r\n                    } else {\r\n                        taskname = zipSequence(gulp, [assertSeq], ctx, (name, runway) => name + (runway === RunWay.sequence ? '-asserts' : '-assertp'));\r\n                    }\r\n\r\n                    return <ITaskInfo>{\r\n                        order: optask.assertsOrder,\r\n                        taskName: taskname\r\n                    }\r\n                });\r\n        } else {\r\n            return Promise.resolve(null);\r\n        }\r\n    }\r\n\r\n    protected createLoader(option: TaskOption, parent: IContext): ITaskLoader {\r\n        if (!_.isFunction(this.config.loaderFactory)) {\r\n            let factory = new LoaderFactory();\r\n            return factory.create(option, parent.env, (cfg, p) => {\r\n                return this.config.contextFactory(cfg, p || parent);\r\n            });\r\n        } else {\r\n            return this.config.loaderFactory(option, parent.env);\r\n        }\r\n    }\r\n\r\n\r\n    protected printHelp(help: boolean | string) {\r\n        if (help === 'en') {\r\n\r\n            console.log(`\r\n                /**\r\n                 * gulp [build] [--env production|development] [--context name] [--root path] [--watch] [--test] [--serve] [--release] [--task taskname]\r\n                 * @params\r\n                 *  --env  development or production;\r\n                 *  --context app setting\r\n                 *  --root path, set relative path of the development tool root.\r\n                 *  --watch  watch src file change or not. if changed will auto update to node service. \r\n                 *  --release release web app or not. if [--env production], default to release. \r\n                 *  --test  need auto load test file to node service.\r\n                 *  --deploy run deploy tasks to deploy project.  \r\n                 *  --serve start node web service or not.\r\n                 *  --task taskname  spruce task taskname\r\n                 **/`);\r\n\r\n        } else {\r\n\r\n            console.log(`\r\n                /**\r\n                 * gulp [build] [--env production|development] [--context name] [--root path] [--watch] [--test] [--serve] [--release] [--task taskname]\r\n                 * @params\r\n                 *  --env 发布环境 默认开发环境development;\r\n                 *  --context 设置配置文件;\r\n                 *  --root path, 设置编译环境相对路径\r\n                 *  --watch  是否需要动态监听文件变化\r\n                 *  --release 是否release编译, [--env production] 默认release \r\n                 *  --test  启动自动化测试\r\n                 *  --deploy 运行加载deploy tasks, 编译发布项目。  \r\n                 *  --serve  是否在开发模式下 开启node web服务\r\n                 *  --task taskname  运行单独任务taskname\r\n                 **/`);\r\n\r\n        }\r\n    }\r\n}\r\n"]}