{"version":3,"sources":["tools.js","tools.ts"],"names":["__export","m","p","exports","hasOwnProperty","_","require","minimist","LoaderFactory_1","development_core_1","chalk","Development","dirname","option","_classCallCheck","this","globals","gulp","env","_this","root","help","console","log","grey","printHelp","loadTasks","tasks","then","tseq","filterTaskSequence","runSequence","catch","err","error","process","exit","seq","rseq","each","it","isString","push","isArray","filter","itm","ctx","_this2","Promise","all","map","optask","dist","loader","createLoader","loadContext","bindingContext","green","loadSubTask","subtask","load","loadAssertTasks","setup","tsq","flatten","assertsTask","subGroupTask","resolve","toSequence","tsqs","runTasks","addToSequence","_this3","_ret","subopt","name","subTaskName","src","v","subseq","length","first","last","frn","lsn","subName","task","order","subTaskOrder","taskName","_typeof","_this4","asserts","_ret2","keys","op","sr","pipes","watch","isFunction","isNull","isUndefined","getSrc","oper","Operation","build","getDist","sq","assertSeq","t","assertsOrder","_this5","loaderFactory","factory","LoaderFactory","opt","create","setting","devtool","setupTask","callback","options","argv","slice","string","default","NODE_ENV","run","start"],"mappings":"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","file":"../tools.js","sourcesContent":["\"use strict\";\nfunction __export(m) {\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\n}\nconst _ = require('lodash');\nconst minimist = require('minimist');\nconst LoaderFactory_1 = require('./LoaderFactory');\nconst development_core_1 = require('development-core');\nconst chalk = require('chalk');\n// export * from 'development-core';\n__export(require('./LoaderFactory'));\n__export(require('./loaders/BaseLoader'));\nclass Development {\n    /**\n     * Creates an instance of Development.\n     *\n     * @param {string} dirname\n     * @param {DevelopConfig} option\n     *\n     * @memberOf Development\n     */\n    constructor(dirname, option) {\n        this.dirname = dirname;\n        this.option = option;\n        /**\n         * global data.\n         *\n         *\n         * @private\n         * @type {*}\n         * @memberOf Development\n         */\n        this.globals = {};\n    }\n    /**\n     * create development tool.\n     *\n     * @static\n     * @param {Gulp} gulp\n     * @param {string} dirname\n     * @param {(DevelopConfig | ITaskOption[])} setting\n     * @returns {Development}\n     *\n     * @memberOf Development\n     */\n    static create(gulp, dirname, setting) {\n        let option = _.isArray(setting) ? { tasks: setting } : setting;\n        let devtool = new Development(dirname, option);\n        option.setupTask = option.setupTask || 'build';\n        gulp.task(option.setupTask, (callback) => {\n            var options = minimist(process.argv.slice(2), {\n                string: 'env',\n                default: { env: process.env.NODE_ENV || 'development' }\n            });\n            return devtool.run(gulp, options);\n        });\n        gulp.task('default', () => {\n            gulp.start(option.setupTask);\n        });\n        return devtool;\n    }\n    /**\n     * run task.\n     *\n     * @param {Gulp} gulp\n     * @param {IEnvOption} env\n     * @returns {Promise<any>}\n     *\n     * @memberOf Development\n     */\n    run(gulp, env) {\n        if (!env.root) {\n            env.root = this.dirname;\n        }\n        if (env.help) {\n            console.log(chalk.grey('... main help  ...'));\n            this.printHelp(env.help);\n        }\n        return this.loadTasks(gulp, this.option.tasks, env)\n            .then(tseq => {\n            tseq = this.filterTaskSequence(tseq);\n            console.log(chalk.grey('run sequenec tasks:'), tseq);\n            return development_core_1.runSequence(gulp, this.filterTaskSequence(tseq));\n        })\n            .catch(err => {\n            console.error(err);\n            process.exit(1);\n        });\n    }\n    /**\n     * filter task sequence.\n     *\n     * @private\n     * @param {Src[]} seq\n     * @returns {Src[]}\n     *\n     * @memberOf Development\n     */\n    filterTaskSequence(seq) {\n        let rseq = [];\n        _.each(seq, it => {\n            if (!it) {\n                return;\n            }\n            if (_.isString(it)) {\n                rseq.push(it);\n            }\n            else if (_.isArray(it)) {\n                rseq.push(_.filter(it, itm => !!itm));\n            }\n        });\n        return rseq;\n    }\n    bindingContext(ctx) {\n        // cfg.env = cfg.env || this.env;\n        ctx.globals = this.globals;\n        return ctx;\n    }\n    loadTasks(gulp, tasks, env) {\n        return Promise.all(_.map(_.isArray(tasks) ? tasks : [tasks], optask => {\n            optask.dist = optask.dist || 'dist';\n            // console.log(chalk.grey('begin load task via loader:'), optask.loader);\n            let loader = this.createLoader(optask, env);\n            return loader.loadContext(env)\n                .then(ctx => {\n                this.bindingContext(ctx);\n                console.log(chalk.green('task context loaded.'));\n                if (ctx.env.help) {\n                    if (ctx.printHelp) {\n                        console.log(chalk.grey('...development default help...'));\n                        ctx.printHelp(_.isString(ctx.env.help) ? ctx.env.help : '');\n                    }\n                    return [];\n                }\n                else {\n                    return this.loadSubTask(gulp, ctx)\n                        .then(subtask => {\n                        return Promise.all([\n                            loader.load(ctx),\n                            this.loadAssertTasks(gulp, ctx)\n                        ])\n                            .then(tasks => {\n                            console.log(chalk.green('tasks loaded.'));\n                            return this.setup(gulp, ctx, tasks[0], tasks[1], subtask);\n                        });\n                    });\n                }\n            });\n        })).then(tsq => {\n            return _.flatten(tsq);\n        });\n    }\n    setup(gulp, ctx, tasks, assertsTask, subGroupTask) {\n        return Promise.resolve(development_core_1.toSequence(gulp, tasks, ctx))\n            .then(tsqs => {\n            // if (_.isFunction(context.option['runTasks'])) {\n            //     return context.option['runTasks'](context.oper, tsqs, subGroupTask, assertsTask);\n            // } else if (_.isArray(context.option['runTasks'])) {\n            //     tsqs = context.option['runTasks'];\n            // } else \n            if (ctx.runTasks) {\n                return ctx.runTasks(tsqs, assertsTask, subGroupTask);\n            }\n            // console.log(assertsTask);\n            ctx.addToSequence(tsqs, assertsTask);\n            ctx.addToSequence(tsqs, subGroupTask);\n            return tsqs;\n        });\n    }\n    /**\n     * load sub tasks as group task.\n     *\n     * @protected\n     * @param {Gulp} gulp\n     * @param {ITaskContext} ctx\n     * @returns {Promise<Src>}\n     *\n     * @memberOf Development\n     */\n    loadSubTask(gulp, ctx) {\n        if (ctx['tasks']) {\n            let optask = ctx.option;\n            _.each(_.isArray(optask.tasks) ? optask.tasks : [optask.tasks], subopt => {\n                subopt.name = ctx.subTaskName(subopt.name);\n                subopt.src = subopt.src || optask.src;\n                subopt.dist = subopt.dist || optask.dist;\n            });\n            return this.loadTasks(gulp, optask.tasks, ctx.env)\n                .then(subseq => {\n                if (subseq && subseq.length > 0) {\n                    let first = _.first(subseq);\n                    let last = _.last(subseq);\n                    let frn = _.isArray(first) ? _.first(first) : first;\n                    let lsn = _.isArray(last) ? _.last(last) : last;\n                    let subName = ctx.subTaskName(`${frn}-${lsn}`, '-sub');\n                    gulp.task(subName, () => {\n                        return development_core_1.runSequence(gulp, subseq);\n                    });\n                    return {\n                        order: optask.subTaskOrder,\n                        taskName: subName\n                    };\n                }\n                else {\n                    return null;\n                }\n            });\n        }\n        else {\n            return Promise.resolve(null);\n        }\n    }\n    /**\n     * load asserts tasks.\n     *\n     * @protected\n     * @param {Gulp} gulp\n     * @param {ITaskContext} ctx\n     * @returns {Promise<Src>}\n     *\n     * @memberOf Development\n     */\n    loadAssertTasks(gulp, ctx) {\n        let optask = ctx.option;\n        if (ctx.option.asserts) {\n            let tasks = [];\n            _.each(_.keys(optask.asserts), name => {\n                let op;\n                let sr = optask.asserts[name];\n                if (_.isString(sr)) {\n                    op = { src: sr, loader: [{ name: name, pipes: [], watch: true }] };\n                }\n                else if (_.isArray(sr)) {\n                    if (sr.length > 0) {\n                        if (_.isString(_.first(sr))) {\n                            op = { src: sr, loader: [{ name: name, pipes: [], watch: true }] };\n                        }\n                        else {\n                            op = { name: name, loader: sr, watch: true };\n                        }\n                    }\n                }\n                else if (_.isFunction(sr)) {\n                    op = { loader: sr, name: name };\n                }\n                else {\n                    op = sr;\n                    op.name = op.name || name;\n                }\n                ;\n                if (_.isNull(op) || _.isUndefined(op)) {\n                    return;\n                }\n                op.src = op.src || (ctx.getSrc({ oper: development_core_1.Operation.build }) + '/**/*.' + name);\n                op.dist = op.dist || ctx.getDist({ oper: development_core_1.Operation.build });\n                tasks.push(op);\n            });\n            return Promise.all(_.map(tasks, task => {\n                return this.loadTasks(gulp, task, ctx.env)\n                    .then(sq => {\n                    return {\n                        task: task,\n                        sq: sq\n                    };\n                });\n            }))\n                .then(tseq => {\n                // asserts tasks run mutil.\n                let assertSeq = _.map(tseq, t => {\n                    let subseq = t.sq;\n                    let name;\n                    if (subseq && subseq.length > 0) {\n                        if (subseq.length === 1) {\n                            return subseq[0];\n                        }\n                        name = ctx.subTaskName(t.task);\n                        gulp.task(name, () => {\n                            return development_core_1.runSequence(gulp, subseq);\n                        });\n                    }\n                    else {\n                        name = ctx.subTaskName(t.sq);\n                    }\n                    return name;\n                });\n                return {\n                    order: ctx.option.assertsOrder,\n                    taskName: assertSeq\n                };\n            });\n        }\n        else {\n            return Promise.resolve(null);\n        }\n    }\n    createLoader(option, env) {\n        let loader = null;\n        if (!_.isFunction(this.option.loaderFactory)) {\n            let factory = new LoaderFactory_1.LoaderFactory();\n            this.option.loaderFactory = (opt) => {\n                return factory.create(opt, env);\n            };\n        }\n        loader = this.option.loaderFactory(option, env);\n        return loader;\n    }\n    printHelp(help) {\n        if (help === 'en') {\n            console.log(`\r\n                /**\r\n                 * gulp [build] [--env production|development] [--context name] [--root path] [--watch] [--test] [--serve] [--release] [--task taskname]\r\n                 * @params\r\n                 *  --env  development or production;\r\n                 *  --context app setting\r\n                 *  --root path, set relative path of the development tool root.\r\n                 *  --watch  watch src file change or not. if changed will auto update to node service. \r\n                 *  --release release web app or not. if [--env production], default to release. \r\n                 *  --test  need auto load test file to node service.\r\n                 *  --deploy run deploy tasks to deploy project.  \r\n                 *  --serve start node web service or not.\r\n                 *  --task taskname  spruce task taskname\r\n                 **/`);\n        }\n        else {\n            console.log(`\r\n                /**\r\n                 * gulp [build] [--env production|development] [--context name] [--root path] [--watch] [--test] [--serve] [--release] [--task taskname]\r\n                 * @params\r\n                 *  --env 发布环境 默认开发环境development;\r\n                 *  --context 设置配置文件;\r\n                 *  --root path, 设置编译环境相对路径\r\n                 *  --watch  是否需要动态监听文件变化\r\n                 *  --release 是否release编译, [--env production] 默认release \r\n                 *  --test  启动自动化测试\r\n                 *  --deploy 运行加载deploy tasks, 编译发布项目。  \r\n                 *  --serve  是否在开发模式下 开启node web服务\r\n                 *  --task taskname  运行单独任务taskname\r\n                 **/`);\n        }\n    }\n}\nexports.Development = Development;\n","import * as _ from 'lodash';\r\nimport { Gulp, TaskCallback } from 'gulp';\r\n\r\nimport * as minimist from 'minimist';\r\nimport { ITaskLoader } from './ITaskLoader';\r\nimport { LoaderFactory } from './LoaderFactory';\r\nimport { TaskOption, Operation, Src, toSequence, runSequence, ITaskContext, IAsserts, ITaskInfo, ITask, ITaskOption, IEnvOption, IDynamicTaskOption } from 'development-core';\r\nimport { DevelopConfig } from './DevelopConfig';\r\nimport * as chalk from 'chalk';\r\n\r\nexport * from './DevelopConfig';\r\n// export * from 'development-core';\r\nexport * from './ITaskLoader';\r\nexport * from './LoaderFactory';\r\nexport * from './loaders/BaseLoader';\r\n\r\nexport class Development {\r\n    /**\r\n     * global data.\r\n     * \r\n     * \r\n     * @private\r\n     * @type {*}\r\n     * @memberOf Development\r\n     */\r\n    private globals: any = {};\r\n    /**\r\n     * create development tool.\r\n     * \r\n     * @static\r\n     * @param {Gulp} gulp\r\n     * @param {string} dirname\r\n     * @param {(DevelopConfig | ITaskOption[])} setting\r\n     * @returns {Development}\r\n     * \r\n     * @memberOf Development\r\n     */\r\n    static create(gulp: Gulp, dirname: string, setting: DevelopConfig | ITaskOption[] | IAsserts[]): Development {\r\n        let option = _.isArray(setting) ? { tasks: setting } : setting;\r\n        let devtool = new Development(dirname, option);\r\n        option.setupTask = option.setupTask || 'build';\r\n        gulp.task(option.setupTask, (callback: TaskCallback) => {\r\n            var options: IEnvOption = minimist(process.argv.slice(2), {\r\n                string: 'env',\r\n                default: { env: process.env.NODE_ENV || 'development' }\r\n            });\r\n            return devtool.run(gulp, options);\r\n        });\r\n\r\n        gulp.task('default', () => {\r\n            gulp.start(option.setupTask);\r\n        });\r\n        return devtool;\r\n    }\r\n\r\n    /**\r\n     * Creates an instance of Development.\r\n     * \r\n     * @param {string} dirname\r\n     * @param {DevelopConfig} option\r\n     * \r\n     * @memberOf Development\r\n     */\r\n    private constructor(private dirname: string, protected option: DevelopConfig) {\r\n\r\n    }\r\n\r\n    /**\r\n     * run task.\r\n     * \r\n     * @param {Gulp} gulp\r\n     * @param {IEnvOption} env\r\n     * @returns {Promise<any>}\r\n     * \r\n     * @memberOf Development\r\n     */\r\n    run(gulp: Gulp, env: IEnvOption): Promise<any> {\r\n        if (!env.root) {\r\n            env.root = this.dirname;\r\n        }\r\n\r\n        if (env.help) {\r\n            console.log(chalk.grey('... main help  ...'));\r\n            this.printHelp(env.help);\r\n        }\r\n\r\n        return this.loadTasks(gulp, this.option.tasks, env)\r\n            .then(tseq => {\r\n                tseq = this.filterTaskSequence(tseq);\r\n                console.log(chalk.grey('run sequenec tasks:'), tseq);\r\n                return runSequence(gulp, this.filterTaskSequence(tseq));\r\n            })\r\n            .catch(err => {\r\n                console.error(err);\r\n                process.exit(1);\r\n            });\r\n    }\r\n\r\n    /**\r\n     * filter task sequence. \r\n     * \r\n     * @private\r\n     * @param {Src[]} seq\r\n     * @returns {Src[]}\r\n     * \r\n     * @memberOf Development\r\n     */\r\n    private filterTaskSequence(seq: Src[]): Src[] {\r\n        let rseq: Src[] = [];\r\n        _.each(seq, it => {\r\n            if (!it) {\r\n                return;\r\n            }\r\n            if (_.isString(it)) {\r\n                rseq.push(it);\r\n            } else if (_.isArray(it)) {\r\n                rseq.push(_.filter(it, itm => !!itm));\r\n            }\r\n        });\r\n        return rseq;\r\n    }\r\n\r\n    private bindingContext(ctx: ITaskContext): ITaskContext {\r\n        // cfg.env = cfg.env || this.env;\r\n        ctx.globals = this.globals;\r\n        return ctx;\r\n    }\r\n\r\n    protected loadTasks(gulp: Gulp, tasks: TaskOption, env: IEnvOption): Promise<Src[]> {\r\n        return Promise.all<Src[]>(\r\n            _.map(_.isArray(tasks) ? <ITaskOption[]>tasks : [<ITaskOption>tasks], optask => {\r\n                optask.dist = optask.dist || 'dist';\r\n                // console.log(chalk.grey('begin load task via loader:'), optask.loader);\r\n                let loader = this.createLoader(optask, env);\r\n\r\n                return loader.loadContext(env)\r\n                    .then(ctx => {\r\n                        this.bindingContext(ctx);\r\n                        console.log(chalk.green('task context loaded.'));\r\n                        if (ctx.env.help) {\r\n                            if (ctx.printHelp) {\r\n                                console.log(chalk.grey('...development default help...'));\r\n                                ctx.printHelp(_.isString(ctx.env.help) ? ctx.env.help : '');\r\n                            }\r\n                            return [];\r\n                        } else {\r\n                            return this.loadSubTask(gulp, ctx)\r\n                                .then(subtask => {\r\n                                    return Promise.all([\r\n                                        loader.load(ctx),\r\n                                        this.loadAssertTasks(gulp, ctx)\r\n                                    ])\r\n                                        .then(tasks => {\r\n                                            console.log(chalk.green('tasks loaded.'));\r\n                                            return this.setup(gulp, ctx, tasks[0], tasks[1], subtask)\r\n                                        });\r\n                                });\r\n                        }\r\n                    });\r\n            })\r\n        ).then(tsq => {\r\n            return _.flatten(tsq);\r\n        });\r\n    }\r\n\r\n    protected setup(gulp: Gulp, ctx: ITaskContext, tasks: ITask[], assertsTask: ITaskInfo, subGroupTask: ITaskInfo): Promise<Src[]> {\r\n        return Promise.resolve(toSequence(gulp, tasks, ctx))\r\n            .then(tsqs => {\r\n                // if (_.isFunction(context.option['runTasks'])) {\r\n                //     return context.option['runTasks'](context.oper, tsqs, subGroupTask, assertsTask);\r\n                // } else if (_.isArray(context.option['runTasks'])) {\r\n                //     tsqs = context.option['runTasks'];\r\n                // } else \r\n                if (ctx.runTasks) {\r\n                    return ctx.runTasks(tsqs, assertsTask, subGroupTask);\r\n                }\r\n                // console.log(assertsTask);\r\n                ctx.addToSequence(tsqs, assertsTask);\r\n                ctx.addToSequence(tsqs, subGroupTask);\r\n\r\n                return tsqs;\r\n            });\r\n    }\r\n\r\n    /**\r\n     * load sub tasks as group task.\r\n     * \r\n     * @protected\r\n     * @param {Gulp} gulp\r\n     * @param {ITaskContext} ctx\r\n     * @returns {Promise<Src>}\r\n     * \r\n     * @memberOf Development\r\n     */\r\n    protected loadSubTask(gulp: Gulp, ctx: ITaskContext): Promise<ITaskInfo> {\r\n\r\n        if (ctx['tasks']) {\r\n            let optask = <ITaskOption>ctx.option;\r\n            _.each(_.isArray(optask.tasks) ? optask.tasks : [optask.tasks], subopt => {\r\n                subopt.name = ctx.subTaskName(subopt.name);\r\n                subopt.src = subopt.src || optask.src;\r\n                subopt.dist = subopt.dist || optask.dist;\r\n            });\r\n            return this.loadTasks(gulp, optask.tasks, ctx.env)\r\n                .then(subseq => {\r\n                    if (subseq && subseq.length > 0) {\r\n                        let first = _.first(subseq);\r\n                        let last = _.last(subseq);\r\n                        let frn = _.isArray(first) ? _.first(first) : first;\r\n                        let lsn = _.isArray(last) ? _.last(last) : last;\r\n\r\n                        let subName = ctx.subTaskName(`${frn}-${lsn}`, '-sub');\r\n                        gulp.task(subName, () => {\r\n                            return runSequence(gulp, subseq);\r\n                        });\r\n\r\n                        return <ITaskInfo>{\r\n                            order: optask.subTaskOrder,\r\n                            taskName: subName\r\n                        };\r\n                    } else {\r\n                        return null;\r\n                    }\r\n                });\r\n        } else {\r\n            return Promise.resolve(null);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * load asserts tasks.\r\n     * \r\n     * @protected\r\n     * @param {Gulp} gulp\r\n     * @param {ITaskContext} ctx\r\n     * @returns {Promise<Src>}\r\n     * \r\n     * @memberOf Development\r\n     */\r\n    protected loadAssertTasks(gulp: Gulp, ctx: ITaskContext): Promise<ITaskInfo> {\r\n        let optask = ctx.option;\r\n        if (ctx.option.asserts) {\r\n            let tasks: IAsserts[] = [];\r\n            _.each(_.keys(optask.asserts), name => {\r\n                let op: IAsserts;\r\n                let sr = optask.asserts[name];\r\n                if (_.isString(sr)) {\r\n                    op = <IAsserts>{ src: sr, loader: [{ name: name, pipes: [], watch: true }] };\r\n                } else if (_.isArray(sr)) {\r\n                    if (sr.length > 0) {\r\n                        if (_.isString(_.first(<string[]>sr))) {\r\n                            op = <IAsserts>{ src: <string[]>sr, loader: [{ name: name, pipes: [], watch: true }] };\r\n                        } else {\r\n                            op = <IAsserts>{ name: name, loader: <IDynamicTaskOption[]>sr, watch: true };\r\n                        }\r\n                    }\r\n                } else if (_.isFunction(sr)) {\r\n                    op = { loader: sr, name: name };\r\n                } else {\r\n                    op = sr;\r\n                    op.name = op.name || name;\r\n                };\r\n                if (_.isNull(op) || _.isUndefined(op)) {\r\n                    return;\r\n                }\r\n                op.src = op.src || (ctx.getSrc({ oper: Operation.build }) + '/**/*.' + name);\r\n                op.dist = op.dist || ctx.getDist({ oper: Operation.build });\r\n                tasks.push(op);\r\n            });\r\n\r\n            return Promise.all(_.map(tasks, task => {\r\n                return this.loadTasks(gulp, <ITaskOption>task, ctx.env)\r\n                    .then(sq => {\r\n                        return {\r\n                            task: task,\r\n                            sq: sq\r\n                        }\r\n                    });\r\n            }))\r\n                .then(tseq => {\r\n                    // asserts tasks run mutil.\r\n                    let assertSeq = _.map(tseq, t => {\r\n                        let subseq = t.sq;\r\n                        let name;\r\n                        if (subseq && subseq.length > 0) {\r\n                            if (subseq.length === 1) {\r\n                                return subseq[0];\r\n                            }\r\n\r\n                            name = ctx.subTaskName(t.task)\r\n                            gulp.task(name, () => {\r\n                                return runSequence(gulp, subseq);\r\n                            });\r\n                        } else {\r\n                            name = ctx.subTaskName(t.sq);\r\n                        }\r\n\r\n                        return name;\r\n                    });\r\n\r\n\r\n                    return <ITaskInfo>{\r\n                        order: ctx.option.assertsOrder,\r\n                        taskName: assertSeq\r\n                    }\r\n                });\r\n        } else {\r\n            return Promise.resolve(null);\r\n        }\r\n    }\r\n\r\n    protected createLoader(option: ITaskOption, env: IEnvOption): ITaskLoader {\r\n        let loader = null;\r\n        if (!_.isFunction(this.option.loaderFactory)) {\r\n            let factory = new LoaderFactory();\r\n            this.option.loaderFactory = (opt: ITaskOption) => {\r\n                return factory.create(opt, env);\r\n            }\r\n        }\r\n        loader = this.option.loaderFactory(option, env);\r\n        return loader;\r\n    }\r\n\r\n\r\n    protected printHelp(help: boolean | string) {\r\n        if (help === 'en') {\r\n\r\n            console.log(`\r\n                /**\r\n                 * gulp [build] [--env production|development] [--context name] [--root path] [--watch] [--test] [--serve] [--release] [--task taskname]\r\n                 * @params\r\n                 *  --env  development or production;\r\n                 *  --context app setting\r\n                 *  --root path, set relative path of the development tool root.\r\n                 *  --watch  watch src file change or not. if changed will auto update to node service. \r\n                 *  --release release web app or not. if [--env production], default to release. \r\n                 *  --test  need auto load test file to node service.\r\n                 *  --deploy run deploy tasks to deploy project.  \r\n                 *  --serve start node web service or not.\r\n                 *  --task taskname  spruce task taskname\r\n                 **/`);\r\n\r\n        } else {\r\n\r\n            console.log(`\r\n                /**\r\n                 * gulp [build] [--env production|development] [--context name] [--root path] [--watch] [--test] [--serve] [--release] [--task taskname]\r\n                 * @params\r\n                 *  --env 发布环境 默认开发环境development;\r\n                 *  --context 设置配置文件;\r\n                 *  --root path, 设置编译环境相对路径\r\n                 *  --watch  是否需要动态监听文件变化\r\n                 *  --release 是否release编译, [--env production] 默认release \r\n                 *  --test  启动自动化测试\r\n                 *  --deploy 运行加载deploy tasks, 编译发布项目。  \r\n                 *  --serve  是否在开发模式下 开启node web服务\r\n                 *  --task taskname  运行单独任务taskname\r\n                 **/`);\r\n\r\n        }\r\n    }\r\n}\r\n\r\n\r\n\r\n\r\n"]}