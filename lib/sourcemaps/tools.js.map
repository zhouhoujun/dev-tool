{"version":3,"sources":["tools.js","tools.ts"],"names":["__export","m","p","exports","hasOwnProperty","_","require","minimist","LoaderFactory_1","development_core_1","chalk","Development","dirname","option","_classCallCheck","this","globals","gulp","env","_this","root","help","console","log","grey","printHelp","loadTasks","tasks","then","tseq","runSequence","catch","err","error","cfg","oper","toSequence","_this2","Promise","all","map","isArray","optask","dist","currentOperation","loader","createLoader","loadConfg","green","isString","bindingConfig","loadSubTask","subtask","load","loadAssertTasks","setup","tsq","flatten","config","assertsTask","subGroupTask","_this3","t","ts","tsqs","isFunction","runTasks","addTask","each","subopt","name","subTaskName","src","subseq","length","first","last","frn","lsn","subName","task","isNumber","subTaskOrder","order","resolve","_this4","asserts","_ret","keys","op","aop","pipes","watch","some","it","isNull","isUndefined","push","v","sq","assertSeq","assertsOrder","_typeof","_this5","loaderFactory","factory","LoaderFactory","opt","create","setting","devtool","setupTask","callback","options","process","argv","slice","string","default","NODE_ENV","run","start"],"mappings":"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","file":"../tools.js","sourcesContent":["\"use strict\";\nfunction __export(m) {\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\n}\nconst _ = require('lodash');\nconst minimist = require('minimist');\nconst LoaderFactory_1 = require('./LoaderFactory');\nconst development_core_1 = require('development-core');\nconst chalk = require('chalk');\n__export(require('./LoaderFactory'));\n__export(require('./loaders/BaseLoader'));\nclass Development {\n    constructor(dirname, option) {\n        this.dirname = dirname;\n        this.option = option;\n        this.globals = {};\n    }\n    static create(gulp, dirname, setting) {\n        let option = _.isArray(setting) ? { tasks: setting } : setting;\n        let devtool = new Development(dirname, option);\n        option.setupTask = option.setupTask || 'build';\n        gulp.task(option.setupTask, (callback) => {\n            var options = minimist(process.argv.slice(2), {\n                string: 'env',\n                default: { env: process.env.NODE_ENV || 'development' }\n            });\n            return devtool.run(gulp, options);\n        });\n        gulp.task('default', () => {\n            gulp.start(option.setupTask);\n        });\n        return devtool;\n    }\n    run(gulp, env) {\n        if (!env.root) {\n            env.root = this.dirname;\n        }\n        if (env.help) {\n            console.log(chalk.grey('... main help  ...'));\n            this.printHelp(env.help);\n        }\n        return this.loadTasks(gulp, this.option.tasks, env)\n            .then(tseq => {\n            console.log(chalk.grey('run sequenec tasks:'), tseq);\n            return this.runSequence(gulp, tseq);\n        })\n            .catch(err => {\n            console.error(err);\n        });\n    }\n    bindingConfig(cfg) {\n        cfg.globals = this.globals;\n        return cfg;\n    }\n    runSequence(gulp, tasks) {\n        return development_core_1.runSequence(gulp, tasks);\n    }\n    toSequence(tasks, oper) {\n        return development_core_1.toSequence(tasks, oper);\n    }\n    loadTasks(gulp, tasks, env) {\n        return Promise.all(_.map(_.isArray(tasks) ? tasks : [tasks], optask => {\n            optask.dist = optask.dist || 'dist';\n            let oper = development_core_1.currentOperation(env);\n            console.log(chalk.grey('begin load task via loader:'), optask.loader);\n            let loader = this.createLoader(optask);\n            return loader.loadConfg(oper, env)\n                .then(cfg => {\n                console.log(chalk.green('task config loaded.'));\n                if (cfg.env.help) {\n                    if (cfg.printHelp) {\n                        console.log(chalk.grey('...development default help...'));\n                        cfg.printHelp(_.isString(cfg.env.help) ? cfg.env.help : '');\n                    }\n                    return [];\n                }\n                else {\n                    cfg = this.bindingConfig(cfg);\n                    return this.loadSubTask(gulp, cfg)\n                        .then(subtask => {\n                        return Promise.all([\n                            loader.load(cfg),\n                            this.loadAssertTasks(gulp, cfg)\n                        ])\n                            .then(tasks => {\n                            console.log(chalk.green('tasks loaded.'));\n                            return this.setup(gulp, cfg, tasks[0], tasks[1], subtask);\n                        });\n                    });\n                }\n            });\n        })).then(tsq => {\n            return _.flatten(tsq);\n        });\n    }\n    setup(gulp, config, tasks, assertsTask, subGroupTask) {\n        return Promise.all(_.map(tasks, t => {\n            return t(gulp, config);\n        }))\n            .then(ts => {\n            let tsqs = this.toSequence(ts, config.oper);\n            if (_.isFunction(config.option.runTasks)) {\n                return config.option.runTasks(config.oper, tsqs, subGroupTask, assertsTask);\n            }\n            else if (_.isArray(config.option.runTasks)) {\n                tsqs = config.option.runTasks;\n            }\n            else if (config.runTasks) {\n                return config.runTasks(subGroupTask, tsqs, assertsTask);\n            }\n            config.addTask(tsqs, assertsTask);\n            config.addTask(tsqs, subGroupTask);\n            return tsqs;\n        });\n    }\n    loadSubTask(gulp, config) {\n        let optask = config.option;\n        if (optask.tasks) {\n            _.each(_.isArray(optask.tasks) ? optask.tasks : [optask.tasks], subopt => {\n                subopt.name = config.subTaskName(subopt.name);\n                subopt.src = subopt.src || optask.src;\n                subopt.dist = subopt.dist || optask.dist;\n            });\n            return this.loadTasks(gulp, optask.tasks, config.env)\n                .then(subseq => {\n                if (subseq && subseq.length > 0) {\n                    let first = _.first(subseq);\n                    let last = _.last(subseq);\n                    let frn = _.isArray(first) ? _.first(first) : first;\n                    let lsn = _.isArray(last) ? _.last(last) : last;\n                    let subName = config.subTaskName(`${frn}-${lsn}`, '-sub');\n                    gulp.task(subName, () => {\n                        return development_core_1.runSequence(gulp, subseq);\n                    });\n                    if (_.isNumber(config.option.subTaskOrder)) {\n                        return {\n                            order: config.option.subTaskOrder,\n                            name: subName\n                        };\n                    }\n                    else {\n                        return subName;\n                    }\n                }\n                else {\n                    return null;\n                }\n            });\n        }\n        else {\n            return Promise.resolve(null);\n        }\n    }\n    loadAssertTasks(gulp, config) {\n        let optask = config.option;\n        if (optask.asserts) {\n            let tasks = [];\n            _.each(_.keys(optask.asserts), name => {\n                let op;\n                let aop = optask.asserts[name];\n                if (_.isString(aop)) {\n                    op = { src: aop, loader: [{ name: name, pipes: [] }, { name: `${name}-watch`, watch: [name] }] };\n                }\n                else if (_.isArray(aop)) {\n                    if (_.some(aop, it => _.isString(aop))) {\n                        op = { src: aop, loader: [{ name: name, pipes: [] }, { name: `${name}-watch`, watch: [name] }] };\n                    }\n                    else {\n                        op = { loader: aop };\n                    }\n                }\n                else {\n                    op = aop;\n                }\n                ;\n                if (_.isNull(op) || _.isUndefined(op)) {\n                    return;\n                }\n                op.name = config.subTaskName(name, '-assert');\n                op.src = op.src || (optask.src + '/**/*.' + name);\n                op.dist = op.dist || optask.dist;\n                tasks.push(op);\n            });\n            return Promise.all(_.map(tasks, task => {\n                return this.loadTasks(gulp, task, config.env)\n                    .then(sq => {\n                    return {\n                        task: task,\n                        sq: sq\n                    };\n                });\n            }))\n                .then(tseq => {\n                let assertSeq = _.map(tseq, t => {\n                    let subseq = t.sq;\n                    if (subseq && subseq.length > 0) {\n                        if (subseq.length === 1) {\n                            return subseq[0];\n                        }\n                        gulp.task(t.task.name, () => {\n                            return development_core_1.runSequence(gulp, subseq);\n                        });\n                        return t.task.name;\n                    }\n                    return t.sq;\n                });\n                if (_.isNumber(config.option.assertsOrder)) {\n                    return {\n                        order: config.option.assertsOrder,\n                        name: assertSeq\n                    };\n                }\n                else {\n                    return assertSeq;\n                }\n            });\n        }\n        else {\n            return Promise.resolve(null);\n        }\n    }\n    createLoader(option) {\n        let loader = null;\n        if (!_.isFunction(this.option.loaderFactory)) {\n            let factory = new LoaderFactory_1.LoaderFactory();\n            this.option.loaderFactory = (opt) => {\n                return factory.create(opt);\n            };\n        }\n        loader = this.option.loaderFactory(option);\n        return loader;\n    }\n    printHelp(help) {\n        if (help === 'en') {\n            console.log(`\r\n                /**\r\n                 * gulp [build] [--env production|development] [--config name] [--root path] [--watch] [--test] [--serve] [--release] [--task taskname]\r\n                 * @params\r\n                 *  --env  development or production;\r\n                 *  --config app setting\r\n                 *  --root path, set relative path of the development tool root.\r\n                 *  --watch  watch src file change or not. if changed will auto update to node service. \r\n                 *  --release release web app or not. if [--env production], default to release. \r\n                 *  --test  need auto load test file to node service.\r\n                 *  --deploy run deploy tasks to deploy project.  \r\n                 *  --serve start node web service or not.\r\n                 *  --task taskname  spruce task taskname\r\n                 **/`);\n        }\n        else {\n            console.log(`\r\n                /**\r\n                 * gulp [build] [--env production|development] [--config name] [--root path] [--watch] [--test] [--serve] [--release] [--task taskname]\r\n                 * @params\r\n                 *  --env 发布环境 默认开发环境development;\r\n                 *  --config 设置配置文件;\r\n                 *  --root path, 设置编译环境相对路径\r\n                 *  --watch  是否需要动态监听文件变化\r\n                 *  --release 是否release编译, [--env production] 默认release \r\n                 *  --test  启动自动化测试\r\n                 *  --deploy 运行加载deploy tasks, 编译发布项目。  \r\n                 *  --serve  是否在开发模式下 开启node web服务\r\n                 *  --task taskname  运行单独任务taskname\r\n                 **/`);\n        }\n    }\n}\nexports.Development = Development;\n","import * as _ from 'lodash';\r\nimport { Gulp, TaskCallback } from 'gulp';\r\n\r\nimport * as minimist from 'minimist';\r\nimport { ITaskLoader } from './ITaskLoader';\r\nimport { LoaderFactory } from './LoaderFactory';\r\nimport {\r\n    Src, currentOperation, toSequence, runSequence\r\n    , Asserts, Task, TaskOption, Operation, EnvOption\r\n    , ITaskResult, TaskResult, TaskConfig\r\n} from 'development-core';\r\nimport { DevelopConfig } from './DevelopConfig';\r\nimport * as chalk from 'chalk';\r\n\r\nexport * from './DevelopConfig';\r\n// export * from 'development-core';\r\nexport * from './ITaskLoader';\r\nexport * from './LoaderFactory';\r\nexport * from './loaders/BaseLoader';\r\n\r\nexport class Development {\r\n    /**\r\n     * global data.\r\n     * \r\n     * \r\n     * @private\r\n     * @type {*}\r\n     * @memberOf Development\r\n     */\r\n    private globals: any = {};\r\n    /**\r\n     * create development tool.\r\n     * \r\n     * @static\r\n     * @param {Gulp} gulp\r\n     * @param {string} dirname\r\n     * @param {(DevelopConfig | TaskOption[])} setting\r\n     * @returns {Development}\r\n     * \r\n     * @memberOf Development\r\n     */\r\n    static create(gulp: Gulp, dirname: string, setting: DevelopConfig | TaskOption[]): Development {\r\n        let option = _.isArray(setting) ? { tasks: setting } : setting;\r\n        let devtool = new Development(dirname, option);\r\n        option.setupTask = option.setupTask || 'build';\r\n        gulp.task(option.setupTask, (callback: TaskCallback) => {\r\n            var options: EnvOption = minimist(process.argv.slice(2), {\r\n                string: 'env',\r\n                default: { env: process.env.NODE_ENV || 'development' }\r\n            });\r\n            return devtool.run(gulp, options);\r\n        });\r\n\r\n        gulp.task('default', () => {\r\n            gulp.start(option.setupTask);\r\n        });\r\n        return devtool;\r\n    }\r\n\r\n    private constructor(private dirname: string, protected option: DevelopConfig) {\r\n\r\n    }\r\n\r\n    run(gulp: Gulp, env: EnvOption): Promise<any> {\r\n        if (!env.root) {\r\n            env.root = this.dirname;\r\n        }\r\n\r\n        if (env.help) {\r\n            console.log(chalk.grey('... main help  ...'));\r\n            this.printHelp(env.help);\r\n        }\r\n\r\n        return this.loadTasks(gulp, this.option.tasks, env)\r\n            .then(tseq => {\r\n                console.log(chalk.grey('run sequenec tasks:'), tseq);\r\n                return this.runSequence(gulp, tseq);\r\n            })\r\n            .catch(err => {\r\n                console.error(err);\r\n            });\r\n    }\r\n\r\n    private bindingConfig(cfg: TaskConfig): TaskConfig {\r\n        // cfg.env = cfg.env || this.env;\r\n        cfg.globals = this.globals;\r\n        return cfg;\r\n    }\r\n\r\n    /**\r\n     * run task sequence.\r\n     * \r\n     * @protected\r\n     * @param {Gulp} gulp\r\n     * @param {Src[]} tasks\r\n     * @returns {Promise<any>}\r\n     * \r\n     * @memberOf Development\r\n     */\r\n    runSequence(gulp: Gulp, tasks: Src[]): Promise<any> {\r\n        return runSequence(gulp, tasks);\r\n    }\r\n\r\n    protected toSequence(tasks: Array<TaskResult | TaskResult[] | void>, oper: Operation): Src[] {\r\n        return toSequence(tasks, oper);\r\n    }\r\n\r\n    protected loadTasks(gulp: Gulp, tasks: TaskOption | TaskOption[], env: EnvOption): Promise<Src[]> {\r\n        return Promise.all<Src[]>(\r\n            _.map(_.isArray(tasks) ? <TaskOption[]>tasks : [<TaskOption>tasks], optask => {\r\n                optask.dist = optask.dist || 'dist';\r\n                let oper: Operation = currentOperation(env);\r\n\r\n                console.log(chalk.grey('begin load task via loader:'), optask.loader);\r\n                let loader = this.createLoader(optask);\r\n\r\n                return loader.loadConfg(oper, env)\r\n                    .then(cfg => {\r\n                        console.log(chalk.green('task config loaded.'));\r\n                        if (cfg.env.help) {\r\n                            if (cfg.printHelp) {\r\n                                console.log(chalk.grey('...development default help...'));\r\n                                cfg.printHelp(_.isString(cfg.env.help) ? cfg.env.help : '');\r\n                            }\r\n                            return [];\r\n                        } else {\r\n                            cfg = this.bindingConfig(cfg);\r\n                            return this.loadSubTask(gulp, cfg)\r\n                                .then(subtask => {\r\n                                    return Promise.all([\r\n                                        loader.load(cfg),\r\n                                        this.loadAssertTasks(gulp, cfg)\r\n                                    ])\r\n                                        .then(tasks => {\r\n                                            console.log(chalk.green('tasks loaded.'));\r\n                                            return this.setup(gulp, cfg, tasks[0], tasks[1], subtask)\r\n                                        });\r\n                                });\r\n                        }\r\n                    });\r\n            })\r\n        ).then(tsq => {\r\n            return _.flatten(tsq);\r\n        });\r\n    }\r\n\r\n    protected setup(gulp: Gulp, config: TaskConfig, tasks: Task[], assertsTask: TaskResult, subGroupTask: TaskResult): Promise<Src[]> {\r\n        return Promise.all(_.map(tasks, t => {\r\n            return t(gulp, config);\r\n        }))\r\n            .then(ts => {\r\n                let tsqs: Src[] = this.toSequence(ts, config.oper);\r\n                if (_.isFunction(config.option.runTasks)) {\r\n                    return config.option.runTasks(config.oper, tsqs, subGroupTask, assertsTask);\r\n                } else if (_.isArray(config.option.runTasks)) {\r\n                    tsqs = config.option.runTasks;\r\n                } else if (config.runTasks) {\r\n                    return config.runTasks(subGroupTask, tsqs, assertsTask);\r\n                }\r\n\r\n                config.addTask(tsqs, assertsTask);\r\n                config.addTask(tsqs, subGroupTask);\r\n\r\n                return tsqs;\r\n            });\r\n    }\r\n\r\n    /**\r\n     * load sub tasks as group task.\r\n     * \r\n     * @protected\r\n     * @param {Gulp} gulp\r\n     * @param {TaskConfig} config\r\n     * @returns {Promise<Src>}\r\n     * \r\n     * @memberOf Development\r\n     */\r\n    protected loadSubTask(gulp: Gulp, config: TaskConfig): Promise<TaskResult> {\r\n        let optask = config.option;\r\n        if (optask.tasks) {\r\n            _.each(_.isArray(optask.tasks) ? optask.tasks : [optask.tasks], subopt => {\r\n                subopt.name = config.subTaskName(subopt.name);\r\n                subopt.src = subopt.src || optask.src;\r\n                subopt.dist = subopt.dist || optask.dist;\r\n            });\r\n            return this.loadTasks(gulp, optask.tasks, config.env)\r\n                .then(subseq => {\r\n                    if (subseq && subseq.length > 0) {\r\n                        let first = _.first(subseq);\r\n                        let last = _.last(subseq);\r\n                        let frn = _.isArray(first) ? _.first(first) : first;\r\n                        let lsn = _.isArray(last) ? _.last(last) : last;\r\n                        let subName = config.subTaskName(`${frn}-${lsn}`, '-sub');\r\n                        gulp.task(subName, () => {\r\n                            return runSequence(gulp, subseq);\r\n                        })\r\n\r\n                        if (_.isNumber(config.option.subTaskOrder)) {\r\n                            return <ITaskResult>{\r\n                                order: config.option.subTaskOrder,\r\n                                name: subName\r\n                            };\r\n                        } else {\r\n                            return subName;\r\n                        }\r\n                    } else {\r\n                        return null;\r\n                    }\r\n                });\r\n        } else {\r\n            return Promise.resolve(null);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * load asserts tasks.\r\n     * \r\n     * @protected\r\n     * @param {Gulp} gulp\r\n     * @param {TaskConfig} config\r\n     * @returns {Promise<Src>}\r\n     * \r\n     * @memberOf Development\r\n     */\r\n    protected loadAssertTasks(gulp: Gulp, config: TaskConfig): Promise<TaskResult> {\r\n        let optask = config.option;\r\n        if (optask.asserts) {\r\n            let tasks: Asserts[] = [];\r\n            _.each(_.keys(optask.asserts), name => {\r\n                let op: Asserts;\r\n                let aop = optask.asserts[name];\r\n                if (_.isString(aop)) {\r\n                    op = <Asserts>{ src: aop, loader: [{ name: name, pipes: [] }, { name: `${name}-watch`, watch: [name] }] };\r\n                } else if (_.isArray(aop)) {\r\n                    if (_.some(aop, it => _.isString(aop))) {\r\n                        op = <Asserts>{ src: aop, loader: [{ name: name, pipes: [] }, { name: `${name}-watch`, watch: [name] }] };\r\n                    } else {\r\n                        op = <Asserts>{ loader: aop };\r\n                    }\r\n                } else {\r\n                    op = aop;\r\n                };\r\n                if (_.isNull(op) || _.isUndefined(op)) {\r\n                    return;\r\n                }\r\n                op.name = config.subTaskName(name, '-assert');\r\n                op.src = op.src || (optask.src + '/**/*.' + name);\r\n                op.dist = op.dist || optask.dist;\r\n                tasks.push(op);\r\n            });\r\n\r\n            return Promise.all(_.map(tasks, task => {\r\n                return this.loadTasks(gulp, <TaskOption>task, config.env)\r\n                    .then(sq => {\r\n                        return {\r\n                            task: task,\r\n                            sq: sq\r\n                        }\r\n                    });\r\n            }))\r\n                .then(tseq => {\r\n                    // asserts tasks run mutil.\r\n                    let assertSeq = _.map(tseq, t => {\r\n                        let subseq = t.sq;\r\n                        if (subseq && subseq.length > 0) {\r\n                            if (subseq.length === 1) {\r\n                                return subseq[0];\r\n                            }\r\n                            gulp.task(t.task.name, () => {\r\n                                return runSequence(gulp, subseq);\r\n                            })\r\n                            return t.task.name;\r\n                        }\r\n                        return t.sq;\r\n                    });\r\n                    if (_.isNumber(config.option.assertsOrder)) {\r\n                        return <ITaskResult>{\r\n                            order: config.option.assertsOrder,\r\n                            name: assertSeq\r\n                        };\r\n                    } else {\r\n                        return assertSeq;\r\n                    }\r\n                });\r\n        } else {\r\n            return Promise.resolve(null);\r\n        }\r\n    }\r\n\r\n    protected createLoader(option: TaskOption): ITaskLoader {\r\n        let loader = null;\r\n        if (!_.isFunction(this.option.loaderFactory)) {\r\n            let factory = new LoaderFactory();\r\n            this.option.loaderFactory = (opt: TaskOption) => {\r\n                return factory.create(opt);\r\n            }\r\n        }\r\n        loader = this.option.loaderFactory(option);\r\n        return loader;\r\n    }\r\n\r\n\r\n    protected printHelp(help: boolean | string) {\r\n        if (help === 'en') {\r\n\r\n            console.log(`\r\n                /**\r\n                 * gulp [build] [--env production|development] [--config name] [--root path] [--watch] [--test] [--serve] [--release] [--task taskname]\r\n                 * @params\r\n                 *  --env  development or production;\r\n                 *  --config app setting\r\n                 *  --root path, set relative path of the development tool root.\r\n                 *  --watch  watch src file change or not. if changed will auto update to node service. \r\n                 *  --release release web app or not. if [--env production], default to release. \r\n                 *  --test  need auto load test file to node service.\r\n                 *  --deploy run deploy tasks to deploy project.  \r\n                 *  --serve start node web service or not.\r\n                 *  --task taskname  spruce task taskname\r\n                 **/`);\r\n\r\n        } else {\r\n\r\n            console.log(`\r\n                /**\r\n                 * gulp [build] [--env production|development] [--config name] [--root path] [--watch] [--test] [--serve] [--release] [--task taskname]\r\n                 * @params\r\n                 *  --env 发布环境 默认开发环境development;\r\n                 *  --config 设置配置文件;\r\n                 *  --root path, 设置编译环境相对路径\r\n                 *  --watch  是否需要动态监听文件变化\r\n                 *  --release 是否release编译, [--env production] 默认release \r\n                 *  --test  启动自动化测试\r\n                 *  --deploy 运行加载deploy tasks, 编译发布项目。  \r\n                 *  --serve  是否在开发模式下 开启node web服务\r\n                 *  --task taskname  运行单独任务taskname\r\n                 **/`);\r\n\r\n        }\r\n    }\r\n}\r\n\r\n\r\n\r\n\r\n"]}