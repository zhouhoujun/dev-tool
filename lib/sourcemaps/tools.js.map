{"version":3,"sources":["tools.js","tools.ts"],"names":["__export","m","p","exports","hasOwnProperty","runSequence","gulp","tasks","ps","Promise","resolve","length","_","each","task","then","taskErr","taskStop","reslove","reject","tskmap","isArray","t","err","e","some","values","it","on","start","console","error","files","directory","express","res","fn","fs_1","readdirSync","fname","filePn","fst","lstatSync","isDirectory","concat","push","getCurrentDist","ds","oper","dist","TaskConfig_1","Operation","build","test","e2e","release","deploy","addTask","taskSequence","rst","isString","name","isNumber","order","splice","createTask","dt","cfg","tk","subTaskName","createWatchTask","watchs","isFunction","watch","last","event","watchChanged","map","w","log","chalk","cyan","call","option","src","createPipesTask","pipes","psrc","stram","pipe","stream","output","outputs","all","once","dest","getDist","catch","red","dynamicTask","env","taskseq","require","minimist","LoaderFactory_1","Development","dirname","_classCallCheck","this","globals","_this","root","help","grey","printHelp","loadTasks","tseq","fileFilter","dynamicTasks","deft","arguments","undefined","_this2","seq","orderBy","NaN","flatten","toSquence","_this3","optask","loader","createLoader","loadConfg","green","bindingConfig","loadSubTask","subtask","load","loadAssertTasks","setup","tsq","config","assertsTask","subGroupTask","_this4","ts","tsqs","runTasks","subopt","subseq","first","frn","lsn","subName","subTaskOrder","_this5","asserts","_ret","keys","op","aop","isNull","isUndefined","v","sq","assertSeq","assertsOrder","_typeof","_this6","loaderFactory","factory","LoaderFactory","opt","create","setting","devtool","setupTask","callback","options","process","argv","slice","string","default","NODE_ENV","run"],"mappings":"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","file":"../tools.js","sourcesContent":["\"use strict\";\nfunction __export(m) {\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\n}\nconst _ = require('lodash');\nconst fs_1 = require('fs');\nconst minimist = require('minimist');\nconst LoaderFactory_1 = require('./LoaderFactory');\nconst TaskConfig_1 = require('./TaskConfig');\nconst chalk = require('chalk');\n__export(require('./TaskConfig'));\n__export(require('./LoaderFactory'));\n__export(require('./loaders/BaseLoader'));\nclass Development {\n    constructor(dirname, option) {\n        this.dirname = dirname;\n        this.option = option;\n        this.globals = {};\n    }\n    static create(gulp, dirname, setting) {\n        let option = _.isArray(setting) ? { tasks: setting } : setting;\n        let devtool = new Development(dirname, option);\n        option.setupTask = option.setupTask || 'build';\n        gulp.task(option.setupTask, (callback) => {\n            var options = minimist(process.argv.slice(2), {\n                string: 'env',\n                default: { env: process.env.NODE_ENV || 'development' }\n            });\n            return devtool.run(gulp, options);\n        });\n        gulp.task('default', () => {\n            gulp.start(option.setupTask);\n        });\n        return devtool;\n    }\n    run(gulp, env) {\n        if (!env.root) {\n            env.root = this.dirname;\n        }\n        this.env = env;\n        if (env.help) {\n            console.log(chalk.grey('... main help  ...'));\n            this.printHelp(env.help);\n        }\n        return this.loadTasks(gulp, this.option.tasks, env)\n            .then(tseq => {\n            console.log(chalk.grey('run sequenec tasks:'), tseq);\n            return this.runSequence(gulp, tseq);\n        })\n            .catch(err => {\n            console.error(err);\n        });\n    }\n    bindingConfig(cfg) {\n        cfg.env = cfg.env || this.env;\n        cfg.globals = this.globals;\n        cfg.fileFilter = cfg.fileFilter || files;\n        cfg.runSequence = cfg.runSequence || runSequence;\n        cfg.addTask = cfg.addTask || addTask;\n        cfg.dynamicTasks = cfg.dynamicTasks || ((tasks) => {\n            return dynamicTask(tasks, cfg.oper, cfg.env);\n        });\n        cfg.subTaskName = cfg.subTaskName || ((name, deft = '') => {\n            return cfg.option.name ? `${cfg.option.name}-${name || deft}` : name;\n        });\n        cfg.getDist = cfg.getDist || ((ds) => {\n            if (ds) {\n                let dist = getCurrentDist(ds, cfg.oper);\n                if (dist) {\n                    return dist;\n                }\n            }\n            return getCurrentDist(cfg.option, cfg.oper);\n        });\n        return cfg;\n    }\n    runSequence(gulp, tasks) {\n        return runSequence(gulp, tasks);\n    }\n    toSquence(tasks, oper) {\n        let seq = [];\n        tasks = _.orderBy(tasks, t => {\n            if (t) {\n                if (_.isString(t)) {\n                    return NaN;\n                }\n                else if (_.isArray(t)) {\n                    return NaN;\n                }\n                else {\n                    return t.order;\n                }\n            }\n            return NaN;\n        });\n        _.each(tasks, t => {\n            if (!t) {\n                return;\n            }\n            if (_.isString(t)) {\n                seq.push(t);\n            }\n            else if (_.isArray(t)) {\n                seq.push(_.flatten(this.toSquence(t, oper)));\n            }\n            else {\n                if (t.name) {\n                    if (t.oper && ((t.oper & oper) > 0)) {\n                        seq.push(t.name);\n                    }\n                }\n            }\n        });\n        return seq;\n    }\n    loadTasks(gulp, tasks, env) {\n        return Promise.all(_.map(_.isArray(tasks) ? tasks : [tasks], optask => {\n            optask.dist = optask.dist || 'dist';\n            let oper;\n            if (env.deploy) {\n                oper = TaskConfig_1.Operation.deploy;\n            }\n            else if (env.release) {\n                oper = TaskConfig_1.Operation.release;\n            }\n            else if (env.e2e) {\n                oper = TaskConfig_1.Operation.e2e;\n            }\n            else if (env.test) {\n                oper = TaskConfig_1.Operation.test;\n            }\n            else {\n                oper = TaskConfig_1.Operation.build;\n            }\n            console.log(chalk.grey('begin load task via loader:'), optask.loader);\n            let loader = this.createLoader(optask);\n            return loader.loadConfg(oper, env)\n                .then(cfg => {\n                console.log(chalk.green('task config loaded.'));\n                if (cfg.env.help) {\n                    if (cfg.printHelp) {\n                        console.log(chalk.grey('...development default help...'));\n                        cfg.printHelp(_.isString(cfg.env.help) ? cfg.env.help : '');\n                    }\n                    return [];\n                }\n                else {\n                    cfg = this.bindingConfig(cfg);\n                    return this.loadSubTask(gulp, cfg)\n                        .then(subtask => {\n                        return Promise.all([\n                            loader.load(cfg),\n                            this.loadAssertTasks(gulp, cfg)\n                        ])\n                            .then(tasks => {\n                            console.log(chalk.green('tasks loaded.'));\n                            return this.setup(gulp, cfg, tasks[0], tasks[1], subtask);\n                        });\n                    });\n                }\n            });\n        })).then(tsq => {\n            return _.flatten(tsq);\n        });\n    }\n    setup(gulp, config, tasks, assertsTask, subGroupTask) {\n        return Promise.all(_.map(tasks, t => {\n            return t(gulp, config);\n        }))\n            .then(ts => {\n            let tsqs = this.toSquence(ts, config.oper);\n            if (_.isFunction(config.option.runTasks)) {\n                return config.option.runTasks(config.oper, tsqs, subGroupTask, assertsTask);\n            }\n            else if (_.isArray(config.option.runTasks)) {\n                tsqs = config.option.runTasks;\n            }\n            else if (config.runTasks) {\n                return config.runTasks(subGroupTask, tsqs, assertsTask);\n            }\n            config.addTask(tsqs, assertsTask);\n            config.addTask(tsqs, subGroupTask);\n            return tsqs;\n        });\n    }\n    loadSubTask(gulp, config) {\n        let optask = config.option;\n        if (optask.tasks) {\n            _.each(_.isArray(optask.tasks) ? optask.tasks : [optask.tasks], subopt => {\n                subopt.name = config.subTaskName(subopt.name);\n                subopt.src = subopt.src || optask.src;\n                subopt.dist = subopt.dist || optask.dist;\n            });\n            return this.loadTasks(gulp, optask.tasks, config.env)\n                .then(subseq => {\n                if (subseq && subseq.length > 0) {\n                    let first = _.first(subseq);\n                    let last = _.last(subseq);\n                    let frn = _.isArray(first) ? _.first(first) : first;\n                    let lsn = _.isArray(last) ? _.last(last) : last;\n                    let subName = config.subTaskName(`${frn}-${lsn}`, '-sub');\n                    gulp.task(subName, () => {\n                        return runSequence(gulp, subseq);\n                    });\n                    if (_.isNumber(config.option.subTaskOrder)) {\n                        return {\n                            order: config.option.subTaskOrder,\n                            name: subName\n                        };\n                    }\n                    else {\n                        return subName;\n                    }\n                }\n                else {\n                    return null;\n                }\n            });\n        }\n        else {\n            return Promise.resolve(null);\n        }\n    }\n    loadAssertTasks(gulp, config) {\n        let optask = config.option;\n        if (optask.asserts) {\n            let tasks = [];\n            _.each(_.keys(optask.asserts), name => {\n                let op;\n                let aop = optask.asserts[name];\n                if (_.isString(aop)) {\n                    op = { src: aop, loader: [{ name: name, pipes: [] }, { name: `${name}-watch`, watch: [name] }] };\n                }\n                else if (_.isArray(aop)) {\n                    if (_.some(aop, it => _.isString(aop))) {\n                        op = { src: aop, loader: [{ name: name, pipes: [] }, { name: `${name}-watch`, watch: [name] }] };\n                    }\n                    else {\n                        op = { loader: aop };\n                    }\n                }\n                else {\n                    op = aop;\n                }\n                ;\n                if (_.isNull(op) || _.isUndefined(op)) {\n                    return;\n                }\n                op.name = config.subTaskName(name, '-assert');\n                op.src = op.src || (optask.src + '/**/*.' + name);\n                op.dist = op.dist || optask.dist;\n                tasks.push(op);\n            });\n            return Promise.all(_.map(tasks, task => {\n                return this.loadTasks(gulp, task, config.env)\n                    .then(sq => {\n                    return {\n                        task: task,\n                        sq: sq\n                    };\n                });\n            }))\n                .then(tseq => {\n                let assertSeq = _.map(tseq, t => {\n                    let subseq = t.sq;\n                    if (subseq && subseq.length > 0) {\n                        if (subseq.length === 1) {\n                            return subseq[0];\n                        }\n                        gulp.task(t.task.name, () => {\n                            return runSequence(gulp, subseq);\n                        });\n                        return t.task.name;\n                    }\n                    return t.sq;\n                });\n                if (_.isNumber(config.option.assertsOrder)) {\n                    return {\n                        order: config.option.assertsOrder,\n                        name: assertSeq\n                    };\n                }\n                else {\n                    return assertSeq;\n                }\n            });\n        }\n        else {\n            return Promise.resolve(null);\n        }\n    }\n    createLoader(option) {\n        let loader = null;\n        if (!_.isFunction(this.option.loaderFactory)) {\n            let factory = new LoaderFactory_1.LoaderFactory();\n            this.option.loaderFactory = (opt) => {\n                return factory.create(opt);\n            };\n        }\n        loader = this.option.loaderFactory(option);\n        return loader;\n    }\n    printHelp(help) {\n        if (help === 'en') {\n            console.log(`\r\n                /**\r\n                 * gulp [build] [--env production|development] [--config name] [--root path] [--watch] [--test] [--serve] [--release] [--task taskname]\r\n                 * @params\r\n                 *  --env  development or production;\r\n                 *  --config app setting\r\n                 *  --root path, set relative path of the development tool root.\r\n                 *  --watch  watch src file change or not. if changed will auto update to node service. \r\n                 *  --release release web app or not. if [--env production], default to release. \r\n                 *  --test  need auto load test file to node service.\r\n                 *  --deploy run deploy tasks to deploy project.  \r\n                 *  --serve start node web service or not.\r\n                 *  --task taskname  spruce task taskname\r\n                 **/`);\n        }\n        else {\n            console.log(`\r\n                /**\r\n                 * gulp [build] [--env production|development] [--config name] [--root path] [--watch] [--test] [--serve] [--release] [--task taskname]\r\n                 * @params\r\n                 *  --env 发布环境 默认开发环境development;\r\n                 *  --config 设置配置文件;\r\n                 *  --root path, 设置编译环境相对路径\r\n                 *  --watch  是否需要动态监听文件变化\r\n                 *  --release 是否release编译, [--env production] 默认release \r\n                 *  --test  启动自动化测试\r\n                 *  --deploy 运行加载deploy tasks, 编译发布项目。  \r\n                 *  --serve  是否在开发模式下 开启node web服务\r\n                 *  --task taskname  运行单独任务taskname\r\n                 **/`);\n        }\n    }\n}\nexports.Development = Development;\nfunction runSequence(gulp, tasks) {\n    let ps = Promise.resolve();\n    if (tasks && tasks.length > 0) {\n        _.each(tasks, task => {\n            ps = ps.then(() => {\n                let taskErr = null, taskStop = null;\n                return new Promise((reslove, reject) => {\n                    let tskmap = {};\n                    _.each(_.isArray(task) ? task : [task], t => {\n                        tskmap[t] = false;\n                    });\n                    taskErr = (err) => {\n                        reject(err);\n                    };\n                    taskStop = (e) => {\n                        tskmap[e.task] = true;\n                        if (!_.some(_.values(tskmap), it => !it)) {\n                            reslove();\n                        }\n                    };\n                    gulp.on('task_stop', taskStop)\n                        .on('task_err', taskErr);\n                    gulp.start(task);\n                })\n                    .then(() => {\n                    if (gulp['removeListener']) {\n                        gulp['removeListener']('task_stop', taskStop);\n                        gulp['removeListener']('task_err', taskErr);\n                    }\n                }, err => {\n                    if (gulp['removeListener']) {\n                        gulp['removeListener']('task_stop', taskStop);\n                        gulp['removeListener']('task_err', taskErr);\n                    }\n                    console.error(err);\n                });\n            });\n        });\n    }\n    return ps;\n}\nexports.runSequence = runSequence;\nfunction files(directory, express) {\n    let res = [];\n    express = express || ((fn) => true);\n    _.each(fs_1.readdirSync(directory), fname => {\n        let filePn = directory + '/' + fname;\n        var fst = fs_1.lstatSync(filePn);\n        if (!fst.isDirectory()) {\n            if (express(filePn)) {\n                res.push(filePn);\n            }\n        }\n        else {\n            res = res.concat(files(filePn, express));\n        }\n    });\n    return res;\n}\nexports.files = files;\nfunction getCurrentDist(ds, oper) {\n    let dist;\n    switch (oper) {\n        case TaskConfig_1.Operation.build:\n            dist = ds.build || ds.dist;\n            break;\n        case TaskConfig_1.Operation.test:\n            dist = ds.test || ds.build || ds.dist;\n            break;\n        case TaskConfig_1.Operation.e2e:\n            dist = ds.e2e || ds.build || ds.dist;\n            break;\n        case TaskConfig_1.Operation.release:\n            dist = ds.release || ds.dist;\n            break;\n        case TaskConfig_1.Operation.deploy:\n            dist = ds.deploy || ds.dist;\n            break;\n        default:\n            dist = '';\n            break;\n    }\n    return dist;\n}\nfunction addTask(taskSequence, rst) {\n    if (!rst) {\n        return taskSequence;\n    }\n    if (_.isString(rst) || _.isArray(rst)) {\n        taskSequence.push(rst);\n    }\n    else if (rst.name) {\n        if (_.isNumber(rst.order) && rst.order >= 0 && rst.order < taskSequence.length) {\n            taskSequence.splice(rst.order, 0, rst.name);\n            return taskSequence;\n        }\n        taskSequence.push(rst.name);\n    }\n    return taskSequence;\n}\nfunction createTask(dt) {\n    return (gulp, cfg) => {\n        let tk = cfg.subTaskName(dt.name);\n        gulp.task(tk, () => {\n            return dt.task(cfg, dt, gulp);\n        });\n        return tk;\n    };\n}\nfunction createWatchTask(dt) {\n    return (gulp, cfg) => {\n        let watchs = _.isFunction(dt.watch) ? dt.watch(cfg) : dt.watch;\n        if (!_.isFunction(_.last(watchs))) {\n            watchs.push((event) => {\n                dt.watchChanged && dt.watchChanged(event, cfg);\n            });\n        }\n        watchs = _.map(watchs, w => {\n            if (_.isString(w)) {\n                return cfg.subTaskName(w);\n            }\n            return w;\n        });\n        gulp.task(dt.name, () => {\n            console.log('watch, src:', chalk.cyan.call(chalk, cfg.option.src));\n            gulp.watch(cfg.option.src, watchs);\n        });\n        return dt.name;\n    };\n}\nfunction createPipesTask(dt) {\n    return (gulp, cfg) => {\n        let tk = cfg.subTaskName(dt.name);\n        gulp.task(tk, () => {\n            let src = Promise.resolve(gulp.src(dt.src || cfg.option.src));\n            if (dt.pipes) {\n                let pipes = _.isFunction(dt.pipes) ? dt.pipes(cfg, dt) : dt.pipes;\n                _.each(pipes, (p) => {\n                    src = src.then(psrc => {\n                        return Promise.resolve((_.isFunction(p) ? p(cfg, dt, gulp) : p))\n                            .then(stram => {\n                            return psrc.pipe(stram);\n                        });\n                    });\n                });\n            }\n            else if (dt.pipe) {\n                src = src.then((stream => {\n                    return dt.pipe(stream, cfg, dt);\n                }));\n            }\n            src.then(stream => {\n                if (dt.output) {\n                    let outputs = _.isFunction(dt.output) ? dt.output(cfg, dt) : dt.output;\n                    return Promise.all(_.map(outputs, output => {\n                        return new Promise((resolve, reject) => {\n                            Promise.resolve((_.isFunction(output) ? output(stream, cfg, dt, gulp) : output))\n                                .then(output => {\n                                stream.pipe(output)\n                                    .once('end', resolve)\n                                    .once('error', reject);\n                            });\n                        });\n                    }));\n                }\n                else {\n                    return new Promise((resolve, reject) => {\n                        stream.pipe(gulp.dest(cfg.getDist(dt)))\n                            .once('end', resolve)\n                            .once('error', reject);\n                    });\n                }\n            });\n            return src.catch(err => {\n                console.log(chalk.red(err));\n            });\n        });\n        return tk;\n    };\n}\nfunction dynamicTask(tasks, oper, env) {\n    let taskseq = [];\n    _.each(_.isArray(tasks) ? tasks : [tasks], dt => {\n        if (dt.oper && (dt.oper & oper) <= 0) {\n            return;\n        }\n        if (dt.watch) {\n            if (!env.watch) {\n                return;\n            }\n            console.log('register watch  dynamic task:', chalk.cyan(dt.name));\n            taskseq.push(createWatchTask(dt));\n        }\n        else if (_.isFunction(dt.task)) {\n            console.log('register custom dynamic task:', chalk.cyan(dt.name));\n            taskseq.push(createTask(dt));\n        }\n        else {\n            console.log('register pipes  dynamic task:', chalk.cyan(dt.name));\n            taskseq.push(createPipesTask(dt));\n        }\n    });\n    return taskseq;\n}\nexports.dynamicTask = dynamicTask;\n","import * as _ from 'lodash';\r\nimport { Gulp, WatchEvent, TaskCallback } from 'gulp';\r\nimport { readdirSync, lstatSync } from 'fs';\r\nimport * as minimist from 'minimist';\r\nimport { ITaskLoader } from './ITaskLoader';\r\nimport { LoaderFactory } from './LoaderFactory';\r\nimport { Src, OutputDist, Asserts, Task, TaskOption, Operation, EnvOption, DynamicTask, ITaskResult, TaskResult, Pipe, TaskConfig } from './TaskConfig';\r\nimport { DevelopConfig } from './DevelopConfig';\r\nimport * as chalk from 'chalk';\r\n\r\nexport * from './DevelopConfig';\r\nexport * from './TaskConfig';\r\nexport * from './ITaskLoader';\r\nexport * from './LoaderFactory';\r\nexport * from './loaders/BaseLoader';\r\n\r\nexport class Development {\r\n    /**\r\n     * global data.\r\n     * \r\n     * \r\n     * @private\r\n     * @type {*}\r\n     * @memberOf Development\r\n     */\r\n    private globals: any = {};\r\n    private env: EnvOption;\r\n    /**\r\n     * create development tool.\r\n     * \r\n     * @static\r\n     * @param {Gulp} gulp\r\n     * @param {string} dirname\r\n     * @param {(DevelopConfig | TaskOption[])} setting\r\n     * @returns {Development}\r\n     * \r\n     * @memberOf Development\r\n     */\r\n    static create(gulp: Gulp, dirname: string, setting: DevelopConfig | TaskOption[]): Development {\r\n        let option = _.isArray(setting) ? { tasks: setting } : setting;\r\n        let devtool = new Development(dirname, option);\r\n        option.setupTask = option.setupTask || 'build';\r\n        gulp.task(option.setupTask, (callback: TaskCallback) => {\r\n            var options: EnvOption = minimist(process.argv.slice(2), {\r\n                string: 'env',\r\n                default: { env: process.env.NODE_ENV || 'development' }\r\n            });\r\n            return devtool.run(gulp, options);\r\n        });\r\n\r\n        gulp.task('default', () => {\r\n            gulp.start(option.setupTask);\r\n        });\r\n        return devtool;\r\n    }\r\n\r\n    private constructor(private dirname: string, protected option: DevelopConfig) {\r\n\r\n    }\r\n\r\n    run(gulp: Gulp, env: EnvOption): Promise<any> {\r\n        if (!env.root) {\r\n            env.root = this.dirname;\r\n        }\r\n        this.env = env;\r\n\r\n        if (env.help) {\r\n            console.log(chalk.grey('... main help  ...'));\r\n            this.printHelp(env.help);\r\n        }\r\n\r\n        return this.loadTasks(gulp, this.option.tasks, env)\r\n            .then(tseq => {\r\n                console.log(chalk.grey('run sequenec tasks:'), tseq);\r\n                return this.runSequence(gulp, tseq);\r\n            })\r\n            .catch(err => {\r\n                console.error(err);\r\n            });\r\n    }\r\n\r\n    private bindingConfig(cfg: TaskConfig): TaskConfig {\r\n        cfg.env = cfg.env || this.env;\r\n        cfg.globals = this.globals;\r\n        cfg.fileFilter = cfg.fileFilter || files;\r\n        cfg.runSequence = cfg.runSequence || runSequence;\r\n        cfg.addTask = cfg.addTask || addTask;\r\n        cfg.dynamicTasks = cfg.dynamicTasks || ((tasks: DynamicTask | DynamicTask[]) => {\r\n            return dynamicTask(tasks, cfg.oper, cfg.env);\r\n        });\r\n        cfg.subTaskName = cfg.subTaskName || ((name, deft = '') => {\r\n            return cfg.option.name ? `${cfg.option.name}-${name || deft}` : name;\r\n        });\r\n        cfg.getDist = cfg.getDist || ((ds?: OutputDist) => {\r\n            if (ds) {\r\n                let dist = getCurrentDist(ds, cfg.oper);\r\n                if (dist) {\r\n                    return dist;\r\n                }\r\n            }\r\n            return getCurrentDist(cfg.option, cfg.oper);\r\n        });\r\n\r\n        return cfg;\r\n    }\r\n\r\n    /**\r\n     * run task sequence.\r\n     * \r\n     * @protected\r\n     * @param {Gulp} gulp\r\n     * @param {Src[]} tasks\r\n     * @returns {Promise<any>}\r\n     * \r\n     * @memberOf Development\r\n     */\r\n    runSequence(gulp: Gulp, tasks: Src[]): Promise<any> {\r\n        return runSequence(gulp, tasks);\r\n    }\r\n\r\n    protected toSquence(tasks: Array<TaskResult | TaskResult[] | void>, oper: Operation): Src[] {\r\n        let seq: Src[] = [];\r\n        tasks = _.orderBy(tasks, t => {\r\n            if (t) {\r\n                if (_.isString(t)) {\r\n                    return NaN;\r\n                } else if (_.isArray(t)) {\r\n                    return NaN;\r\n                } else {\r\n                    return (<ITaskResult>t).order\r\n                }\r\n            }\r\n            return NaN;\r\n        });\r\n\r\n        _.each(tasks, t => {\r\n            if (!t) {\r\n                return;\r\n            }\r\n            if (_.isString(t)) {\r\n                seq.push(t);\r\n            } else if (_.isArray(t)) {\r\n                seq.push(_.flatten(this.toSquence(t, oper)));\r\n            } else {\r\n                if (t.name) {\r\n                    if (t.oper && ((t.oper & oper) > 0)) {\r\n                        seq.push(t.name);\r\n                    }\r\n                }\r\n            }\r\n        });\r\n        return seq;\r\n    }\r\n\r\n    protected loadTasks(gulp: Gulp, tasks: TaskOption | TaskOption[], env: EnvOption): Promise<Src[]> {\r\n        return Promise.all<Src[]>(\r\n            _.map(_.isArray(tasks) ? <TaskOption[]>tasks : [<TaskOption>tasks], optask => {\r\n                optask.dist = optask.dist || 'dist';\r\n                let oper: Operation;\r\n                if (env.deploy) {\r\n                    oper = Operation.deploy;\r\n                } else if (env.release) {\r\n                    oper = Operation.release;\r\n                } else if (env.e2e) {\r\n                    oper = Operation.e2e;\r\n                } else if (env.test) {\r\n                    oper = Operation.test;\r\n                } else {\r\n                    oper = Operation.build;\r\n                }\r\n\r\n                console.log(chalk.grey('begin load task via loader:'), optask.loader);\r\n                let loader = this.createLoader(optask);\r\n\r\n                return loader.loadConfg(oper, env)\r\n                    .then(cfg => {\r\n                        console.log(chalk.green('task config loaded.'));\r\n                        if (cfg.env.help) {\r\n                            if (cfg.printHelp) {\r\n                                console.log(chalk.grey('...development default help...'));\r\n                                cfg.printHelp(_.isString(cfg.env.help) ? cfg.env.help : '');\r\n                            }\r\n                            return [];\r\n                        } else {\r\n                            cfg = this.bindingConfig(cfg);\r\n                            return this.loadSubTask(gulp, cfg)\r\n                                .then(subtask => {\r\n                                    return Promise.all([\r\n                                        loader.load(cfg),\r\n                                        this.loadAssertTasks(gulp, cfg)\r\n                                    ])\r\n                                        .then(tasks => {\r\n                                            console.log(chalk.green('tasks loaded.'));\r\n                                            return this.setup(gulp, cfg, tasks[0], tasks[1], subtask)\r\n                                        });\r\n                                });\r\n                        }\r\n                    });\r\n            })\r\n        ).then(tsq => {\r\n            return _.flatten(tsq);\r\n        });\r\n    }\r\n\r\n    protected setup(gulp: Gulp, config: TaskConfig, tasks: Task[], assertsTask: TaskResult, subGroupTask: TaskResult): Promise<Src[]> {\r\n        return Promise.all(_.map(tasks, t => {\r\n            return t(gulp, config);\r\n        }))\r\n            .then(ts => {\r\n                let tsqs: Src[] = this.toSquence(ts, config.oper);\r\n                if (_.isFunction(config.option.runTasks)) {\r\n                    return config.option.runTasks(config.oper, tsqs, subGroupTask, assertsTask);\r\n                } else if (_.isArray(config.option.runTasks)) {\r\n                    tsqs = config.option.runTasks;\r\n                } else if (config.runTasks) {\r\n                    return config.runTasks(subGroupTask, tsqs, assertsTask);\r\n                }\r\n\r\n                config.addTask(tsqs, assertsTask);\r\n                config.addTask(tsqs, subGroupTask);\r\n\r\n                return tsqs;\r\n            });\r\n    }\r\n\r\n    /**\r\n     * load sub tasks as group task.\r\n     * \r\n     * @protected\r\n     * @param {Gulp} gulp\r\n     * @param {TaskConfig} config\r\n     * @returns {Promise<Src>}\r\n     * \r\n     * @memberOf Development\r\n     */\r\n    protected loadSubTask(gulp: Gulp, config: TaskConfig): Promise<TaskResult> {\r\n        let optask = config.option;\r\n        if (optask.tasks) {\r\n            _.each(_.isArray(optask.tasks) ? optask.tasks : [optask.tasks], subopt => {\r\n                subopt.name = config.subTaskName(subopt.name);\r\n                subopt.src = subopt.src || optask.src;\r\n                subopt.dist = subopt.dist || optask.dist;\r\n            });\r\n            return this.loadTasks(gulp, optask.tasks, config.env)\r\n                .then(subseq => {\r\n                    if (subseq && subseq.length > 0) {\r\n                        let first = _.first(subseq);\r\n                        let last = _.last(subseq);\r\n                        let frn = _.isArray(first) ? _.first(first) : first;\r\n                        let lsn = _.isArray(last) ? _.last(last) : last;\r\n                        let subName = config.subTaskName(`${frn}-${lsn}`, '-sub');\r\n                        gulp.task(subName, () => {\r\n                            return runSequence(gulp, subseq);\r\n                        })\r\n\r\n                        if (_.isNumber(config.option.subTaskOrder)) {\r\n                            return <ITaskResult>{\r\n                                order: config.option.subTaskOrder,\r\n                                name: subName\r\n                            };\r\n                        } else {\r\n                            return subName;\r\n                        }\r\n                    } else {\r\n                        return null;\r\n                    }\r\n                });\r\n        } else {\r\n            return Promise.resolve(null);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * load asserts tasks.\r\n     * \r\n     * @protected\r\n     * @param {Gulp} gulp\r\n     * @param {TaskConfig} config\r\n     * @returns {Promise<Src>}\r\n     * \r\n     * @memberOf Development\r\n     */\r\n    protected loadAssertTasks(gulp: Gulp, config: TaskConfig): Promise<TaskResult> {\r\n        let optask = config.option;\r\n        if (optask.asserts) {\r\n            let tasks: Asserts[] = [];\r\n            _.each(_.keys(optask.asserts), name => {\r\n                let op: Asserts;\r\n                let aop = optask.asserts[name];\r\n                if (_.isString(aop)) {\r\n                    op = <Asserts>{ src: aop, loader: [{ name: name, pipes: [] }, { name: `${name}-watch`, watch: [name] }] };\r\n                } else if (_.isArray(aop)) {\r\n                    if (_.some(aop, it => _.isString(aop))) {\r\n                        op = <Asserts>{ src: aop, loader: [{ name: name, pipes: [] }, { name: `${name}-watch`, watch: [name] }] };\r\n                    } else {\r\n                        op = <Asserts>{ loader: aop };\r\n                    }\r\n                } else {\r\n                    op = aop;\r\n                };\r\n                if (_.isNull(op) || _.isUndefined(op)) {\r\n                    return;\r\n                }\r\n                op.name = config.subTaskName(name, '-assert');\r\n                op.src = op.src || (optask.src + '/**/*.' + name);\r\n                op.dist = op.dist || optask.dist;\r\n                tasks.push(op);\r\n            });\r\n\r\n            return Promise.all(_.map(tasks, task => {\r\n                return this.loadTasks(gulp, <TaskOption>task, config.env)\r\n                    .then(sq => {\r\n                        return {\r\n                            task: task,\r\n                            sq: sq\r\n                        }\r\n                    });\r\n            }))\r\n                .then(tseq => {\r\n                    // asserts tasks run mutil.\r\n                    let assertSeq = _.map(tseq, t => {\r\n                        let subseq = t.sq;\r\n                        if (subseq && subseq.length > 0) {\r\n                            if (subseq.length === 1) {\r\n                                return subseq[0];\r\n                            }\r\n                            gulp.task(t.task.name, () => {\r\n                                return runSequence(gulp, subseq);\r\n                            })\r\n                            return t.task.name;\r\n                        }\r\n                        return t.sq;\r\n                    });\r\n                    if (_.isNumber(config.option.assertsOrder)) {\r\n                        return <ITaskResult>{\r\n                            order: config.option.assertsOrder,\r\n                            name: assertSeq\r\n                        };\r\n                    } else {\r\n                        return assertSeq;\r\n                    }\r\n                });\r\n        } else {\r\n            return Promise.resolve(null);\r\n        }\r\n    }\r\n\r\n    protected createLoader(option: TaskOption): ITaskLoader {\r\n        let loader = null;\r\n        if (!_.isFunction(this.option.loaderFactory)) {\r\n            let factory = new LoaderFactory();\r\n            this.option.loaderFactory = (opt: TaskOption) => {\r\n                return factory.create(opt);\r\n            }\r\n        }\r\n        loader = this.option.loaderFactory(option);\r\n        return loader;\r\n    }\r\n\r\n\r\n    protected printHelp(help: boolean | string) {\r\n        if (help === 'en') {\r\n\r\n            console.log(`\r\n                /**\r\n                 * gulp [build] [--env production|development] [--config name] [--root path] [--watch] [--test] [--serve] [--release] [--task taskname]\r\n                 * @params\r\n                 *  --env  development or production;\r\n                 *  --config app setting\r\n                 *  --root path, set relative path of the development tool root.\r\n                 *  --watch  watch src file change or not. if changed will auto update to node service. \r\n                 *  --release release web app or not. if [--env production], default to release. \r\n                 *  --test  need auto load test file to node service.\r\n                 *  --deploy run deploy tasks to deploy project.  \r\n                 *  --serve start node web service or not.\r\n                 *  --task taskname  spruce task taskname\r\n                 **/`);\r\n\r\n        } else {\r\n\r\n            console.log(`\r\n                /**\r\n                 * gulp [build] [--env production|development] [--config name] [--root path] [--watch] [--test] [--serve] [--release] [--task taskname]\r\n                 * @params\r\n                 *  --env 发布环境 默认开发环境development;\r\n                 *  --config 设置配置文件;\r\n                 *  --root path, 设置编译环境相对路径\r\n                 *  --watch  是否需要动态监听文件变化\r\n                 *  --release 是否release编译, [--env production] 默认release \r\n                 *  --test  启动自动化测试\r\n                 *  --deploy 运行加载deploy tasks, 编译发布项目。  \r\n                 *  --serve  是否在开发模式下 开启node web服务\r\n                 *  --task taskname  运行单独任务taskname\r\n                 **/`);\r\n\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * run task sequence.\r\n * \r\n * @protected\r\n * @param {Gulp} gulp\r\n * @param {Src[]} tasks\r\n * @returns {Promise<any>}\r\n * \r\n * @memberOf Development\r\n */\r\nexport function runSequence(gulp: Gulp, tasks: Src[]): Promise<any> {\r\n    let ps = Promise.resolve();\r\n    if (tasks && tasks.length > 0) {\r\n        _.each(tasks, task => {\r\n            ps = ps.then(() => {\r\n                let taskErr = null, taskStop = null;\r\n                return new Promise((reslove, reject) => {\r\n                    let tskmap: any = {};\r\n                    _.each(_.isArray(task) ? task : [task], t => {\r\n                        tskmap[t] = false;\r\n                    });\r\n                    taskErr = (err) => {\r\n                        reject(err);\r\n                    };\r\n                    taskStop = (e: any) => {\r\n                        tskmap[e.task] = true;\r\n                        if (!_.some(_.values(tskmap), it => !it)) {\r\n                            reslove();\r\n                        }\r\n                    }\r\n                    gulp.on('task_stop', taskStop)\r\n                        .on('task_err', taskErr);\r\n                    gulp.start(task);\r\n                })\r\n                    .then(() => {\r\n                        if (gulp['removeListener']) {\r\n                            gulp['removeListener']('task_stop', taskStop);\r\n                            gulp['removeListener']('task_err', taskErr);\r\n                        }\r\n                    }, err => {\r\n                        if (gulp['removeListener']) {\r\n                            gulp['removeListener']('task_stop', taskStop);\r\n                            gulp['removeListener']('task_err', taskErr);\r\n                        }\r\n                        console.error(err);\r\n                    });\r\n            });\r\n        });\r\n    }\r\n    return ps;\r\n}\r\n\r\n/**\r\n * filter fileName in directory.\r\n * \r\n * @export\r\n * @param {string} directory\r\n * @param {((fileName: string) => boolean)} [express]\r\n * @returns {string[]}\r\n */\r\nexport function files(directory: string, express?: ((fileName: string) => boolean)): string[] {\r\n    let res: string[] = [];\r\n    express = express || ((fn) => true);\r\n    _.each(readdirSync(directory), fname => {\r\n        let filePn = directory + '/' + fname;\r\n        var fst = lstatSync(filePn);\r\n        if (!fst.isDirectory()) {\r\n            if (express(filePn)) {\r\n                res.push(filePn)\r\n            }\r\n        } else {\r\n            res = res.concat(files(filePn, express))\r\n        }\r\n    });\r\n    return res;\r\n}\r\n\r\n\r\n/**\r\n * get dist.\r\n * \r\n * @param {OutputDist} ds\r\n * @param {Operation} oper\r\n * @returns\r\n */\r\nfunction getCurrentDist(ds: OutputDist, oper: Operation) {\r\n    let dist: string;\r\n    switch (oper) {\r\n        case Operation.build:\r\n            dist = ds.build || ds.dist;\r\n            break;\r\n        case Operation.test:\r\n            dist = ds.test || ds.build || ds.dist;\r\n            break;\r\n        case Operation.e2e:\r\n            dist = ds.e2e || ds.build || ds.dist;\r\n            break;\r\n        case Operation.release:\r\n            dist = ds.release || ds.dist;\r\n            break;\r\n        case Operation.deploy:\r\n            dist = ds.deploy || ds.dist;\r\n            break;\r\n        default:\r\n            dist = '';\r\n            break;\r\n    }\r\n    return dist;\r\n}\r\n\r\nfunction addTask(taskSequence: Src[], rst: TaskResult) {\r\n    if (!rst) {\r\n        return taskSequence;\r\n    }\r\n    if (_.isString(rst) || _.isArray(rst)) {\r\n        taskSequence.push(rst);\r\n    } else if (rst.name) {\r\n        if (_.isNumber(rst.order) && rst.order >= 0 && rst.order < taskSequence.length) {\r\n            taskSequence.splice(rst.order, 0, rst.name);\r\n            return taskSequence;\r\n        }\r\n        taskSequence.push(rst.name);\r\n    }\r\n    return taskSequence;\r\n}\r\n\r\n\r\n/**\r\n * promise task.\r\n * \r\n * @param {DynamicTask} dt\r\n * @returns\r\n */\r\nfunction createTask(dt: DynamicTask) {\r\n    return (gulp: Gulp, cfg: TaskConfig) => {\r\n        let tk = cfg.subTaskName(dt.name);\r\n        gulp.task(tk, () => {\r\n            return dt.task(cfg, dt, gulp);\r\n        });\r\n        return tk\r\n    };\r\n}\r\n/**\r\n * create dynamic watch task.\r\n * \r\n * @param {DynamicTask} dt\r\n * @returns\r\n */\r\nfunction createWatchTask(dt: DynamicTask) {\r\n    return (gulp: Gulp, cfg: TaskConfig) => {\r\n        let watchs = _.isFunction(dt.watch) ? dt.watch(cfg) : dt.watch;\r\n        if (!_.isFunction(_.last(watchs))) {\r\n            watchs.push(<WatchCallback>(event: WatchEvent) => {\r\n                dt.watchChanged && dt.watchChanged(event, cfg);\r\n            });\r\n        }\r\n        watchs = _.map(watchs, w => {\r\n            if (_.isString(w)) {\r\n                return cfg.subTaskName(w);\r\n            }\r\n            return w;\r\n        })\r\n        gulp.task(dt.name, () => {\r\n            console.log('watch, src:', chalk.cyan.call(chalk, cfg.option.src));\r\n            gulp.watch(cfg.option.src, watchs)\r\n        });\r\n\r\n        return dt.name;\r\n    };\r\n}\r\nfunction createPipesTask(dt: DynamicTask) {\r\n    return (gulp: Gulp, cfg: TaskConfig) => {\r\n\r\n        let tk = cfg.subTaskName(dt.name);\r\n        gulp.task(tk, () => {\r\n            let src = Promise.resolve(gulp.src(dt.src || cfg.option.src));\r\n            if (dt.pipes) {\r\n                let pipes = _.isFunction(dt.pipes) ? dt.pipes(cfg, dt) : dt.pipes;\r\n                _.each(pipes, (p: Pipe) => {\r\n                    src = src.then(psrc => {\r\n                        return Promise.resolve((_.isFunction(p) ? p(cfg, dt, gulp) : p))\r\n                            .then(stram => {\r\n                                return psrc.pipe(stram)\r\n                            });\r\n                    });\r\n                })\r\n            } else if (dt.pipe) {\r\n                src = src.then((stream => {\r\n                    return dt.pipe(stream, cfg, dt);\r\n                }));\r\n            }\r\n            src.then(stream => {\r\n                if (dt.output) {\r\n                    let outputs = _.isFunction(dt.output) ? dt.output(cfg, dt) : dt.output;\r\n                    return Promise.all(_.map(outputs, output => {\r\n                        return new Promise((resolve, reject) => {\r\n                            Promise.resolve<NodeJS.ReadWriteStream>((_.isFunction(output) ? output(stream, cfg, dt, gulp) : output))\r\n                                .then(output => {\r\n                                    stream.pipe(output)\r\n                                        .once('end', resolve)\r\n                                        .once('error', reject);\r\n                                });\r\n\r\n                        });\r\n                    }));\r\n                } else {\r\n                    return new Promise((resolve, reject) => {\r\n                        stream.pipe(gulp.dest(cfg.getDist(dt)))\r\n                            .once('end', resolve)\r\n                            .once('error', reject);\r\n                    });\r\n                }\r\n            });\r\n            return src.catch(err => {\r\n                console.log(chalk.red(err));\r\n            });\r\n        });\r\n\r\n        return tk;\r\n    }\r\n}\r\n\r\n/**\r\n * dynamic build tasks.\r\n * \r\n * @export\r\n * @param {(DynamicTask | DynamicTask[])} tasks\r\n * @param {Operation} oper\r\n * @returns {Task[]}\r\n */\r\nexport function dynamicTask(tasks: DynamicTask | DynamicTask[], oper: Operation, env: EnvOption): Task[] {\r\n    let taskseq: Task[] = [];\r\n    _.each(_.isArray(tasks) ? tasks : [tasks], dt => {\r\n        if (dt.oper && (dt.oper & oper) <= 0) {\r\n            return;\r\n        }\r\n        if (dt.watch) {\r\n            if (!env.watch) {\r\n                return;\r\n            }\r\n            console.log('register watch  dynamic task:', chalk.cyan(dt.name));\r\n            taskseq.push(createWatchTask(dt));\r\n        } else if (_.isFunction(dt.task)) { // custom task\r\n            console.log('register custom dynamic task:', chalk.cyan(dt.name));\r\n            taskseq.push(createTask(dt));\r\n        } else {\r\n            console.log('register pipes  dynamic task:', chalk.cyan(dt.name));\r\n            // pipe stream task.\r\n            taskseq.push(createPipesTask(dt));\r\n        }\r\n    });\r\n\r\n    return taskseq;\r\n}\r\n\r\n\r\n"]}