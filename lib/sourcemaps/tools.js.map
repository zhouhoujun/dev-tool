{"version":3,"sources":["tools.js","tools.ts"],"names":["__export","m","p","exports","hasOwnProperty","_","require","minimist","LoaderFactory_1","development_core_1","chalk","Development","dirname","option","_classCallCheck","this","globals","gulp","env","root","help","console","log","grey","printHelp","loadTasks","tasks","then","tseq","runSequence","catch","err","error","process","exit","cfg","_this","Promise","all","map","isArray","optask","dist","oper","currentOperation","loader","createLoader","loadConfg","green","isString","bindingConfig","loadSubTask","subtask","load","loadAssertTasks","setup","tsq","flatten","config","assertsTask","subGroupTask","resolve","toSequence","tsqs","runTasks","addToSequence","_this2","_ret","each","subopt","name","subTaskName","src","v","subseq","length","first","last","frn","lsn","subName","task","order","subTaskOrder","_typeof","_this3","asserts","_ret2","keys","op","aop","pipes","watch","some","it","isNull","isUndefined","push","sq","assertSeq","t","assertsOrder","_this4","isFunction","loaderFactory","factory","LoaderFactory","opt","create","setting","devtool","setupTask","callback","options","argv","slice","string","default","NODE_ENV","run","start"],"mappings":"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","file":"../tools.js","sourcesContent":["\"use strict\";\nfunction __export(m) {\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\n}\nconst _ = require('lodash');\nconst minimist = require('minimist');\nconst LoaderFactory_1 = require('./LoaderFactory');\nconst development_core_1 = require('development-core');\nconst chalk = require('chalk');\n__export(require('./LoaderFactory'));\n__export(require('./loaders/BaseLoader'));\nclass Development {\n    constructor(dirname, option) {\n        this.dirname = dirname;\n        this.option = option;\n        this.globals = {};\n    }\n    static create(gulp, dirname, setting) {\n        let option = _.isArray(setting) ? { tasks: setting } : setting;\n        let devtool = new Development(dirname, option);\n        option.setupTask = option.setupTask || 'build';\n        gulp.task(option.setupTask, (callback) => {\n            var options = minimist(process.argv.slice(2), {\n                string: 'env',\n                default: { env: process.env.NODE_ENV || 'development' }\n            });\n            return devtool.run(gulp, options);\n        });\n        gulp.task('default', () => {\n            gulp.start(option.setupTask);\n        });\n        return devtool;\n    }\n    run(gulp, env) {\n        if (!env.root) {\n            env.root = this.dirname;\n        }\n        if (env.help) {\n            console.log(chalk.grey('... main help  ...'));\n            this.printHelp(env.help);\n        }\n        return this.loadTasks(gulp, this.option.tasks, env)\n            .then(tseq => {\n            console.log(chalk.grey('run sequenec tasks:'), tseq);\n            return development_core_1.runSequence(gulp, tseq);\n        })\n            .catch(err => {\n            console.error(err);\n            process.exit(1);\n        });\n    }\n    bindingConfig(cfg) {\n        cfg.globals = this.globals;\n        return cfg;\n    }\n    loadTasks(gulp, tasks, env) {\n        return Promise.all(_.map(_.isArray(tasks) ? tasks : [tasks], optask => {\n            optask.dist = optask.dist || 'dist';\n            let oper = development_core_1.currentOperation(env);\n            console.log(chalk.grey('begin load task via loader:'), optask.loader);\n            let loader = this.createLoader(optask);\n            return loader.loadConfg(oper, env)\n                .then(cfg => {\n                console.log(chalk.green('task config loaded.'));\n                if (cfg.env.help) {\n                    if (cfg.printHelp) {\n                        console.log(chalk.grey('...development default help...'));\n                        cfg.printHelp(_.isString(cfg.env.help) ? cfg.env.help : '');\n                    }\n                    return [];\n                }\n                else {\n                    cfg = this.bindingConfig(cfg);\n                    return this.loadSubTask(gulp, cfg)\n                        .then(subtask => {\n                        return Promise.all([\n                            loader.load(cfg),\n                            this.loadAssertTasks(gulp, cfg)\n                        ])\n                            .then(tasks => {\n                            console.log(chalk.green('tasks loaded.'));\n                            return this.setup(gulp, cfg, tasks[0], tasks[1], subtask);\n                        });\n                    });\n                }\n            });\n        })).then(tsq => {\n            return _.flatten(tsq);\n        });\n    }\n    setup(gulp, config, tasks, assertsTask, subGroupTask) {\n        return Promise.resolve(development_core_1.toSequence(gulp, tasks, config))\n            .then(tsqs => {\n            if (config.runTasks) {\n                return config.runTasks(tsqs, assertsTask, subGroupTask);\n            }\n            config.addToSequence(tsqs, assertsTask);\n            config.addToSequence(tsqs, subGroupTask);\n            return tsqs;\n        });\n    }\n    loadSubTask(gulp, config) {\n        if (config['tasks']) {\n            let optask = config.option;\n            _.each(_.isArray(optask.tasks) ? optask.tasks : [optask.tasks], subopt => {\n                subopt.name = config.subTaskName(subopt.name);\n                subopt.src = subopt.src || optask.src;\n                subopt.dist = subopt.dist || optask.dist;\n            });\n            return this.loadTasks(gulp, optask.tasks, config.env)\n                .then(subseq => {\n                if (subseq && subseq.length > 0) {\n                    let first = _.first(subseq);\n                    let last = _.last(subseq);\n                    let frn = _.isArray(first) ? _.first(first) : first;\n                    let lsn = _.isArray(last) ? _.last(last) : last;\n                    let subName = config.subTaskName(`${frn}-${lsn}`, '-sub');\n                    gulp.task(subName, () => {\n                        return development_core_1.runSequence(gulp, subseq);\n                    });\n                    return {\n                        order: optask.subTaskOrder,\n                        name: subName\n                    };\n                }\n                else {\n                    return null;\n                }\n            });\n        }\n        else {\n            return Promise.resolve(null);\n        }\n    }\n    loadAssertTasks(gulp, config) {\n        let optask = config.option;\n        if (config.option.asserts) {\n            let tasks = [];\n            _.each(_.keys(optask.asserts), name => {\n                let op;\n                let aop = optask.asserts[name];\n                if (_.isString(aop)) {\n                    op = { src: aop, loader: [{ name: name, pipes: [] }, { name: `${name}-watch`, watch: [name] }] };\n                }\n                else if (_.isArray(aop)) {\n                    if (_.some(aop, it => _.isString(aop))) {\n                        op = { src: aop, loader: [{ name: name, pipes: [] }, { name: `${name}-watch`, watch: [name] }] };\n                    }\n                    else {\n                        op = { loader: aop };\n                    }\n                }\n                else {\n                    op = aop;\n                }\n                ;\n                if (_.isNull(op) || _.isUndefined(op)) {\n                    return;\n                }\n                op.name = config.subTaskName(name, '-assert');\n                op.src = op.src || (optask.src + '/**/*.' + name);\n                op.dist = op.dist || optask.dist;\n                tasks.push(op);\n            });\n            return Promise.all(_.map(tasks, task => {\n                return this.loadTasks(gulp, task, config.env)\n                    .then(sq => {\n                    return {\n                        task: task,\n                        sq: sq\n                    };\n                });\n            }))\n                .then(tseq => {\n                let assertSeq = _.map(tseq, t => {\n                    let subseq = t.sq;\n                    let name;\n                    if (subseq && subseq.length > 0) {\n                        if (subseq.length === 1) {\n                            return subseq[0];\n                        }\n                        name = config.subTaskName(t.task);\n                        gulp.task(name, () => {\n                            return development_core_1.runSequence(gulp, subseq);\n                        });\n                    }\n                    else {\n                        name = config.subTaskName(t.sq);\n                    }\n                    return name;\n                });\n                return {\n                    order: config.option.assertsOrder,\n                    name: assertSeq\n                };\n            });\n        }\n        else {\n            return Promise.resolve(null);\n        }\n    }\n    createLoader(option) {\n        let loader = null;\n        if (!_.isFunction(this.option.loaderFactory)) {\n            let factory = new LoaderFactory_1.LoaderFactory();\n            this.option.loaderFactory = (opt) => {\n                return factory.create(opt);\n            };\n        }\n        loader = this.option.loaderFactory(option);\n        return loader;\n    }\n    printHelp(help) {\n        if (help === 'en') {\n            console.log(`\r\n                /**\r\n                 * gulp [build] [--env production|development] [--config name] [--root path] [--watch] [--test] [--serve] [--release] [--task taskname]\r\n                 * @params\r\n                 *  --env  development or production;\r\n                 *  --config app setting\r\n                 *  --root path, set relative path of the development tool root.\r\n                 *  --watch  watch src file change or not. if changed will auto update to node service. \r\n                 *  --release release web app or not. if [--env production], default to release. \r\n                 *  --test  need auto load test file to node service.\r\n                 *  --deploy run deploy tasks to deploy project.  \r\n                 *  --serve start node web service or not.\r\n                 *  --task taskname  spruce task taskname\r\n                 **/`);\n        }\n        else {\n            console.log(`\r\n                /**\r\n                 * gulp [build] [--env production|development] [--config name] [--root path] [--watch] [--test] [--serve] [--release] [--task taskname]\r\n                 * @params\r\n                 *  --env 发布环境 默认开发环境development;\r\n                 *  --config 设置配置文件;\r\n                 *  --root path, 设置编译环境相对路径\r\n                 *  --watch  是否需要动态监听文件变化\r\n                 *  --release 是否release编译, [--env production] 默认release \r\n                 *  --test  启动自动化测试\r\n                 *  --deploy 运行加载deploy tasks, 编译发布项目。  \r\n                 *  --serve  是否在开发模式下 开启node web服务\r\n                 *  --task taskname  运行单独任务taskname\r\n                 **/`);\n        }\n    }\n}\nexports.Development = Development;\n","import * as _ from 'lodash';\r\nimport { Gulp, TaskCallback } from 'gulp';\r\n\r\nimport * as minimist from 'minimist';\r\nimport { ITaskLoader } from './ITaskLoader';\r\nimport { LoaderFactory } from './LoaderFactory';\r\nimport {\r\n    Src, currentOperation, toSequence, runSequence\r\n    , IAsserts, ITaskInfo, ITask, ITaskOption, Operation, IEnvOption, ITaskConfig\r\n} from 'development-core';\r\nimport { DevelopConfig } from './DevelopConfig';\r\nimport * as chalk from 'chalk';\r\n\r\nexport * from './DevelopConfig';\r\n// export * from 'development-core';\r\nexport * from './ITaskLoader';\r\nexport * from './LoaderFactory';\r\nexport * from './loaders/BaseLoader';\r\n\r\nexport class Development {\r\n    /**\r\n     * global data.\r\n     * \r\n     * \r\n     * @private\r\n     * @type {*}\r\n     * @memberOf Development\r\n     */\r\n    private globals: any = {};\r\n    /**\r\n     * create development tool.\r\n     * \r\n     * @static\r\n     * @param {Gulp} gulp\r\n     * @param {string} dirname\r\n     * @param {(DevelopConfig | ITaskOption[])} setting\r\n     * @returns {Development}\r\n     * \r\n     * @memberOf Development\r\n     */\r\n    static create(gulp: Gulp, dirname: string, setting: DevelopConfig | ITaskOption[]): Development {\r\n        let option = _.isArray(setting) ? { tasks: setting } : setting;\r\n        let devtool = new Development(dirname, option);\r\n        option.setupTask = option.setupTask || 'build';\r\n        gulp.task(option.setupTask, (callback: TaskCallback) => {\r\n            var options: IEnvOption = minimist(process.argv.slice(2), {\r\n                string: 'env',\r\n                default: { env: process.env.NODE_ENV || 'development' }\r\n            });\r\n            return devtool.run(gulp, options);\r\n        });\r\n\r\n        gulp.task('default', () => {\r\n            gulp.start(option.setupTask);\r\n        });\r\n        return devtool;\r\n    }\r\n\r\n    private constructor(private dirname: string, protected option: DevelopConfig) {\r\n\r\n    }\r\n\r\n    run(gulp: Gulp, env: IEnvOption): Promise<any> {\r\n        if (!env.root) {\r\n            env.root = this.dirname;\r\n        }\r\n\r\n        if (env.help) {\r\n            console.log(chalk.grey('... main help  ...'));\r\n            this.printHelp(env.help);\r\n        }\r\n\r\n        return this.loadTasks(gulp, this.option.tasks, env)\r\n            .then(tseq => {\r\n                console.log(chalk.grey('run sequenec tasks:'), tseq);\r\n                return runSequence(gulp, tseq);\r\n            })\r\n            .catch(err => {\r\n                console.error(err);\r\n                process.exit(1);\r\n            });\r\n    }\r\n\r\n    private bindingConfig(cfg: ITaskConfig): ITaskConfig {\r\n        // cfg.env = cfg.env || this.env;\r\n        cfg.globals = this.globals;\r\n        return cfg;\r\n    }\r\n\r\n    protected loadTasks(gulp: Gulp, tasks: ITaskOption | ITaskOption[], env: IEnvOption): Promise<Src[]> {\r\n        return Promise.all<Src[]>(\r\n            _.map(_.isArray(tasks) ? <ITaskOption[]>tasks : [<ITaskOption>tasks], optask => {\r\n                optask.dist = optask.dist || 'dist';\r\n                let oper: Operation = currentOperation(env);\r\n\r\n                console.log(chalk.grey('begin load task via loader:'), optask.loader);\r\n                let loader = this.createLoader(optask);\r\n\r\n                return loader.loadConfg(oper, env)\r\n                    .then(cfg => {\r\n                        console.log(chalk.green('task config loaded.'));\r\n                        if (cfg.env.help) {\r\n                            if (cfg.printHelp) {\r\n                                console.log(chalk.grey('...development default help...'));\r\n                                cfg.printHelp(_.isString(cfg.env.help) ? cfg.env.help : '');\r\n                            }\r\n                            return [];\r\n                        } else {\r\n                            cfg = this.bindingConfig(cfg);\r\n                            return this.loadSubTask(gulp, cfg)\r\n                                .then(subtask => {\r\n                                    return Promise.all([\r\n                                        loader.load(cfg),\r\n                                        this.loadAssertTasks(gulp, cfg)\r\n                                    ])\r\n                                        .then(tasks => {\r\n                                            console.log(chalk.green('tasks loaded.'));\r\n                                            return this.setup(gulp, cfg, tasks[0], tasks[1], subtask)\r\n                                        });\r\n                                });\r\n                        }\r\n                    });\r\n            })\r\n        ).then(tsq => {\r\n            return _.flatten(tsq);\r\n        });\r\n    }\r\n\r\n    protected setup(gulp: Gulp, config: ITaskConfig, tasks: ITask[], assertsTask: ITaskInfo, subGroupTask: ITaskInfo): Promise<Src[]> {\r\n        return Promise.resolve(toSequence(gulp, tasks, config))\r\n            .then(tsqs => {\r\n                // if (_.isFunction(config.option['runTasks'])) {\r\n                //     return config.option['runTasks'](config.oper, tsqs, subGroupTask, assertsTask);\r\n                // } else if (_.isArray(config.option['runTasks'])) {\r\n                //     tsqs = config.option['runTasks'];\r\n                // } else \r\n                if (config.runTasks) {\r\n                    return config.runTasks(tsqs, assertsTask, subGroupTask);\r\n                }\r\n\r\n                config.addToSequence(tsqs, assertsTask);\r\n                config.addToSequence(tsqs, subGroupTask);\r\n\r\n                return tsqs;\r\n            });\r\n    }\r\n\r\n    /**\r\n     * load sub tasks as group task.\r\n     * \r\n     * @protected\r\n     * @param {Gulp} gulp\r\n     * @param {ITaskConfig} config\r\n     * @returns {Promise<Src>}\r\n     * \r\n     * @memberOf Development\r\n     */\r\n    protected loadSubTask(gulp: Gulp, config: ITaskConfig): Promise<ITaskInfo> {\r\n\r\n        if (config['tasks']) {\r\n            let optask = <ITaskOption>config.option;\r\n            _.each(_.isArray(optask.tasks) ? optask.tasks : [optask.tasks], subopt => {\r\n                subopt.name = config.subTaskName(subopt.name);\r\n                subopt.src = subopt.src || optask.src;\r\n                subopt.dist = subopt.dist || optask.dist;\r\n            });\r\n            return this.loadTasks(gulp, optask.tasks, config.env)\r\n                .then(subseq => {\r\n                    if (subseq && subseq.length > 0) {\r\n                        let first = _.first(subseq);\r\n                        let last = _.last(subseq);\r\n                        let frn = _.isArray(first) ? _.first(first) : first;\r\n                        let lsn = _.isArray(last) ? _.last(last) : last;\r\n\r\n                        let subName = config.subTaskName(`${frn}-${lsn}`, '-sub');\r\n                        gulp.task(subName, () => {\r\n                            return runSequence(gulp, subseq);\r\n                        });\r\n\r\n                        return <ITaskInfo>{\r\n                            order: optask.subTaskOrder,\r\n                            name: subName\r\n                        };\r\n                    } else {\r\n                        return null;\r\n                    }\r\n                });\r\n        } else {\r\n            return Promise.resolve(null);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * load asserts tasks.\r\n     * \r\n     * @protected\r\n     * @param {Gulp} gulp\r\n     * @param {ITaskConfig} config\r\n     * @returns {Promise<Src>}\r\n     * \r\n     * @memberOf Development\r\n     */\r\n    protected loadAssertTasks(gulp: Gulp, config: ITaskConfig): Promise<ITaskInfo> {\r\n        let optask = config.option;\r\n        if (config.option.asserts) {\r\n            let tasks: IAsserts[] = [];\r\n            _.each(_.keys(optask.asserts), name => {\r\n                let op: IAsserts;\r\n                let aop = optask.asserts[name];\r\n                if (_.isString(aop)) {\r\n                    op = <IAsserts>{ src: aop, loader: [{ name: name, pipes: [] }, { name: `${name}-watch`, watch: [name] }] };\r\n                } else if (_.isArray(aop)) {\r\n                    if (_.some(aop, it => _.isString(aop))) {\r\n                        op = <IAsserts>{ src: aop, loader: [{ name: name, pipes: [] }, { name: `${name}-watch`, watch: [name] }] };\r\n                    } else {\r\n                        op = <IAsserts>{ loader: aop };\r\n                    }\r\n                } else {\r\n                    op = aop;\r\n                };\r\n                if (_.isNull(op) || _.isUndefined(op)) {\r\n                    return;\r\n                }\r\n                op.name = config.subTaskName(name, '-assert');\r\n                op.src = op.src || (optask.src + '/**/*.' + name);\r\n                op.dist = op.dist || optask.dist;\r\n                tasks.push(op);\r\n            });\r\n\r\n            return Promise.all(_.map(tasks, task => {\r\n                return this.loadTasks(gulp, <ITaskOption>task, config.env)\r\n                    .then(sq => {\r\n                        return {\r\n                            task: task,\r\n                            sq: sq\r\n                        }\r\n                    });\r\n            }))\r\n                .then(tseq => {\r\n                    // asserts tasks run mutil.\r\n                    let assertSeq = _.map(tseq, t => {\r\n                        let subseq = t.sq;\r\n                        let name;\r\n                        if (subseq && subseq.length > 0) {\r\n                            if (subseq.length === 1) {\r\n                                return subseq[0];\r\n                            }\r\n\r\n                            name = config.subTaskName(t.task)\r\n                            gulp.task(name, () => {\r\n                                return runSequence(gulp, subseq);\r\n                            });\r\n                        } else {\r\n                            name = config.subTaskName(t.sq);\r\n                        }\r\n\r\n                        return name;\r\n                    });\r\n\r\n\r\n                    return <ITaskInfo>{\r\n                        order: config.option.assertsOrder,\r\n                        name: assertSeq\r\n                    }\r\n                });\r\n        } else {\r\n            return Promise.resolve(null);\r\n        }\r\n    }\r\n\r\n    protected createLoader(option: ITaskOption): ITaskLoader {\r\n        let loader = null;\r\n        if (!_.isFunction(this.option.loaderFactory)) {\r\n            let factory = new LoaderFactory();\r\n            this.option.loaderFactory = (opt: ITaskOption) => {\r\n                return factory.create(opt);\r\n            }\r\n        }\r\n        loader = this.option.loaderFactory(option);\r\n        return loader;\r\n    }\r\n\r\n\r\n    protected printHelp(help: boolean | string) {\r\n        if (help === 'en') {\r\n\r\n            console.log(`\r\n                /**\r\n                 * gulp [build] [--env production|development] [--config name] [--root path] [--watch] [--test] [--serve] [--release] [--task taskname]\r\n                 * @params\r\n                 *  --env  development or production;\r\n                 *  --config app setting\r\n                 *  --root path, set relative path of the development tool root.\r\n                 *  --watch  watch src file change or not. if changed will auto update to node service. \r\n                 *  --release release web app or not. if [--env production], default to release. \r\n                 *  --test  need auto load test file to node service.\r\n                 *  --deploy run deploy tasks to deploy project.  \r\n                 *  --serve start node web service or not.\r\n                 *  --task taskname  spruce task taskname\r\n                 **/`);\r\n\r\n        } else {\r\n\r\n            console.log(`\r\n                /**\r\n                 * gulp [build] [--env production|development] [--config name] [--root path] [--watch] [--test] [--serve] [--release] [--task taskname]\r\n                 * @params\r\n                 *  --env 发布环境 默认开发环境development;\r\n                 *  --config 设置配置文件;\r\n                 *  --root path, 设置编译环境相对路径\r\n                 *  --watch  是否需要动态监听文件变化\r\n                 *  --release 是否release编译, [--env production] 默认release \r\n                 *  --test  启动自动化测试\r\n                 *  --deploy 运行加载deploy tasks, 编译发布项目。  \r\n                 *  --serve  是否在开发模式下 开启node web服务\r\n                 *  --task taskname  运行单独任务taskname\r\n                 **/`);\r\n\r\n        }\r\n    }\r\n}\r\n\r\n\r\n\r\n\r\n"]}