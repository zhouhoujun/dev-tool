{"version":3,"sources":["tools.js","tools.ts"],"names":["__export","m","p","exports","hasOwnProperty","_","require","minimist","LoaderFactory_1","development_core_1","chalk","Development","dirname","config","_classCallCheck","this","globals","gulp","env","_this","root","help","console","log","grey","printHelp","gbctx","getContext","loadTasks","tasks","then","tseq","runWay","RunWay","parallel","runSequence","flattenSequence","catch","err","error","process","exit","globalctx","option","bindingContext","bindingConfig","context","parent","ctx","isUndefined","_this2","Promise","all","map","isArray","optask","dist","loader","createLoader","loadContext","green","isString","load","loadAssertTasks","loadSubTask","tks","setup","tsq","flatten","assertsTask","subGroupTask","resolve","toSequence","tsqs","runTasks","addToSequence","_this3","_ret","each","subopt","name","subTaskName","src","v","subseq","taskname","zipSequence","runway","sequence","order","subTaskOrder","taskName","_typeof","_this4","asserts","_ret2","keys","op","sr","pipes","watch","length","first","isFunction","isNull","getSrc","oper","Operation","build","getDist","push","task","sq","assertSeq","t","assertsOrder","_this5","loaderFactory","factory","LoaderFactory","opt","create","setting","arguments","undefined","devtool","setupTask","callback","options","argv","slice","string","default","NODE_ENV","run","start"],"mappings":"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","file":"../tools.js","sourcesContent":["\"use strict\";\nfunction __export(m) {\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\n}\nconst _ = require('lodash');\nconst minimist = require('minimist');\nconst LoaderFactory_1 = require('./LoaderFactory');\nconst development_core_1 = require('development-core');\nconst chalk = require('chalk');\n__export(require('./LoaderFactory'));\n__export(require('./loaders/BaseLoader'));\nclass Development {\n    /**\n     * Creates an instance of Development.\n     *\n     * @param {string} dirname\n     * @param {DevelopConfig} config\n     *\n     * @memberOf Development\n     */\n    constructor(dirname, config) {\n        this.dirname = dirname;\n        this.config = config;\n        /**\n         * global data.\n         *\n         *\n         * @private\n         * @type {*}\n         * @memberOf Development\n         */\n        this.globals = {};\n    }\n    /**\n     * create development tool.\n     *\n     * @static\n     * @param {Gulp} gulp\n     * @param {string} dirname\n     * @param {(DevelopConfig | Array<ITaskOption | IAssertOption | IDynamicTaskOption>)} setting\n     * @param {any} [runWay=RunWay.sequence]\n     * @returns {Development}\n     *\n     * @memberOf Development\n     */\n    static create(gulp, dirname, setting, runWay = development_core_1.RunWay.sequence) {\n        let option = _.isArray(setting) ? { tasks: setting, runWay: runWay } : setting;\n        if (!_.isUndefined(option.runWay)) {\n            option.runWay = runWay;\n        }\n        let devtool = new Development(dirname, option);\n        option.setupTask = option.setupTask || 'build';\n        gulp.task(option.setupTask, (callback) => {\n            var options = minimist(process.argv.slice(2), {\n                string: 'env',\n                default: { env: process.env.NODE_ENV || 'development' }\n            });\n            return devtool.run(gulp, options);\n        });\n        gulp.task('default', () => {\n            gulp.start(option.setupTask);\n        });\n        return devtool;\n    }\n    /**\n     * run task.\n     *\n     * @param {Gulp} gulp\n     * @param {IEnvOption} env\n     * @returns {Promise<any>}\n     *\n     * @memberOf Development\n     */\n    run(gulp, env) {\n        if (!env.root) {\n            env.root = this.dirname;\n        }\n        if (env.help) {\n            console.log(chalk.grey('... main help  ...'));\n            this.printHelp(env.help);\n        }\n        let gbctx = this.getContext(env);\n        return this.loadTasks(gulp, this.config.tasks, gbctx)\n            .then(tseq => {\n            // console.log(chalk.grey('run sequenec tasks:'), tseq);\n            if (this.config.runWay === development_core_1.RunWay.parallel) {\n                return development_core_1.runSequence(gulp, [development_core_1.flattenSequence(gulp, tseq, gbctx)]);\n            }\n            else {\n                return development_core_1.runSequence(gulp, tseq);\n            }\n        })\n            .catch(err => {\n            console.error(err);\n            process.exit(1);\n        });\n    }\n    getContext(env) {\n        if (!this.globalctx || this.globalctx.env !== env) {\n            let option = this.config.option || {};\n            this.globalctx = this.bindingContext(development_core_1.bindingConfig({\n                env: env,\n                option: option\n            }), null);\n        }\n        return this.globalctx;\n    }\n    bindingContext(context, parent) {\n        let ctx = context;\n        // cfg.env = cfg.env || this.env;\n        ctx.globals = this.globals;\n        ctx.parent = _.isUndefined(parent) ? this.getContext(ctx.env) : parent;\n        return ctx;\n    }\n    loadTasks(gulp, tasks, parent) {\n        return Promise.all(_.map(_.isArray(tasks) ? tasks : [tasks], optask => {\n            optask.dist = optask.dist || 'dist';\n            // console.log(chalk.grey('begin load task via loader:'), optask.loader);\n            let loader = this.createLoader(optask, parent.env);\n            return loader.loadContext(parent.env)\n                .then(ctx => {\n                this.bindingContext(ctx, parent);\n                console.log(chalk.green('task context loaded.'));\n                if (ctx.env.help) {\n                    if (ctx.printHelp) {\n                        console.log(chalk.grey('...development default help...'));\n                        ctx.printHelp(_.isString(ctx.env.help) ? ctx.env.help : '');\n                    }\n                    return [];\n                }\n                else {\n                    return Promise.all([\n                        loader.load(ctx),\n                        this.loadAssertTasks(gulp, ctx),\n                        this.loadSubTask(gulp, ctx)\n                    ])\n                        .then(tks => {\n                        console.log(chalk.green('tasks loaded.'));\n                        return this.setup(gulp, ctx, tks[0], tks[1], tks[2]);\n                    });\n                }\n            });\n        })).then(tsq => {\n            return _.flatten(tsq);\n        });\n    }\n    setup(gulp, ctx, tasks, assertsTask, subGroupTask) {\n        return Promise.resolve(development_core_1.toSequence(gulp, tasks, ctx))\n            .then(tsqs => {\n            // if (_.isFunction(context.option['runTasks'])) {\n            //     return context.option['runTasks'](context.oper, tsqs, subGroupTask, assertsTask);\n            // } else if (_.isArray(context.option['runTasks'])) {\n            //     tsqs = context.option['runTasks'];\n            // } else \n            if (ctx.runTasks) {\n                return ctx.runTasks(tsqs, assertsTask, subGroupTask);\n            }\n            // console.log(assertsTask);\n            ctx.addToSequence(tsqs, assertsTask);\n            ctx.addToSequence(tsqs, subGroupTask);\n            return tsqs;\n        });\n    }\n    /**\n     * load sub tasks as group task.\n     *\n     * @protected\n     * @param {Gulp} gulp\n     * @param {IContext} ctx\n     * @returns {Promise<ITaskInfo>}\n     *\n     * @memberOf Development\n     */\n    loadSubTask(gulp, ctx) {\n        if (ctx.option['tasks']) {\n            let optask = ctx.option;\n            _.each(_.isArray(optask.tasks) ? optask.tasks : [optask.tasks], subopt => {\n                subopt.name = ctx.subTaskName(subopt.name);\n                subopt.src = subopt.src || optask.src;\n                subopt.dist = subopt.dist || optask.dist;\n            });\n            return this.loadTasks(gulp, optask.tasks, ctx)\n                .then(subseq => {\n                let taskname = development_core_1.zipSequence(gulp, subseq, ctx, (name, runway) => name + (runway === development_core_1.RunWay.sequence ? '-sub-seq' : '-sub-par'));\n                if (taskname) {\n                    return {\n                        name: taskname,\n                        order: optask.subTaskOrder,\n                        taskName: taskname\n                    };\n                }\n                else {\n                    return null;\n                }\n            });\n        }\n        else {\n            return Promise.resolve(null);\n        }\n    }\n    /**\n     * load asserts tasks.\n     *\n     * @protected\n     * @param {Gulp} gulp\n     * @param {ITaskContext} ctx\n     * @returns {Promise<Src>}\n     *\n     * @memberOf Development\n     */\n    loadAssertTasks(gulp, ctx) {\n        let optask = ctx.option;\n        if (optask.asserts) {\n            let tasks = [];\n            _.each(_.keys(optask.asserts), name => {\n                let op;\n                let sr = optask.asserts[name];\n                if (_.isString(sr)) {\n                    op = { src: sr, loader: [{ name: name, pipes: [], watch: true }] };\n                }\n                else if (_.isArray(sr)) {\n                    if (sr.length > 0) {\n                        if (_.isString(_.first(sr))) {\n                            op = { src: sr, loader: [{ name: name, pipes: [], watch: true }] };\n                        }\n                        else {\n                            op = { loader: sr, watch: true };\n                        }\n                    }\n                }\n                else if (_.isFunction(sr)) {\n                    op = { loader: sr };\n                }\n                else {\n                    op = sr;\n                }\n                if (_.isNull(op) || _.isUndefined(op)) {\n                    return;\n                }\n                op.name = op.name || ctx.subTaskName(name);\n                op.src = op.src || (ctx.getSrc({ oper: development_core_1.Operation.build }) + '/**/*.' + name);\n                op.dist = op.dist || ctx.getDist({ oper: development_core_1.Operation.build });\n                tasks.push(op);\n            });\n            return Promise.all(_.map(tasks, task => {\n                return this.loadTasks(gulp, task, ctx)\n                    .then(sq => {\n                    return {\n                        task: task,\n                        sq: sq\n                    };\n                });\n            }))\n                .then(tseq => {\n                // asserts tasks run mutil.\n                let assertSeq = _.map(tseq, t => {\n                    return development_core_1.zipSequence(gulp, t.sq, ctx, (name, runway) => ctx.subTaskName(name + (runway === development_core_1.RunWay.sequence ? '-assert-seq' : '-assert-par')));\n                });\n                return {\n                    order: ctx.option.assertsOrder,\n                    taskName: assertSeq\n                };\n            });\n        }\n        else {\n            return Promise.resolve(null);\n        }\n    }\n    createLoader(option, env) {\n        let loader = null;\n        if (!_.isFunction(this.config.loaderFactory)) {\n            let factory = new LoaderFactory_1.LoaderFactory();\n            this.config.loaderFactory = (opt) => {\n                return factory.create(opt, env);\n            };\n        }\n        loader = this.config.loaderFactory(option, env);\n        return loader;\n    }\n    printHelp(help) {\n        if (help === 'en') {\n            console.log(`\r\n                /**\r\n                 * gulp [build] [--env production|development] [--context name] [--root path] [--watch] [--test] [--serve] [--release] [--task taskname]\r\n                 * @params\r\n                 *  --env  development or production;\r\n                 *  --context app setting\r\n                 *  --root path, set relative path of the development tool root.\r\n                 *  --watch  watch src file change or not. if changed will auto update to node service. \r\n                 *  --release release web app or not. if [--env production], default to release. \r\n                 *  --test  need auto load test file to node service.\r\n                 *  --deploy run deploy tasks to deploy project.  \r\n                 *  --serve start node web service or not.\r\n                 *  --task taskname  spruce task taskname\r\n                 **/`);\n        }\n        else {\n            console.log(`\r\n                /**\r\n                 * gulp [build] [--env production|development] [--context name] [--root path] [--watch] [--test] [--serve] [--release] [--task taskname]\r\n                 * @params\r\n                 *  --env 发布环境 默认开发环境development;\r\n                 *  --context 设置配置文件;\r\n                 *  --root path, 设置编译环境相对路径\r\n                 *  --watch  是否需要动态监听文件变化\r\n                 *  --release 是否release编译, [--env production] 默认release \r\n                 *  --test  启动自动化测试\r\n                 *  --deploy 运行加载deploy tasks, 编译发布项目。  \r\n                 *  --serve  是否在开发模式下 开启node web服务\r\n                 *  --task taskname  运行单独任务taskname\r\n                 **/`);\n        }\n    }\n}\nexports.Development = Development;\n","import * as _ from 'lodash';\r\nimport { Gulp, TaskCallback } from 'gulp';\r\n\r\nimport * as minimist from 'minimist';\r\nimport { ITaskLoader } from './ITaskLoader';\r\nimport { LoaderFactory } from './LoaderFactory';\r\nimport { Operation, Src, toSequence, runSequence, bindingConfig, zipSequence, flattenSequence, ITaskContext, ITaskInfo, ITask, IEnvOption, IDynamicTaskOption, RunWay } from 'development-core';\r\nimport { TaskOption, ITaskOption, IAssertOption, IContext } from './TaskOption';\r\nimport { DevelopConfig } from './DevelopConfig';\r\nimport * as chalk from 'chalk';\r\n\r\nexport * from './DevelopConfig';\r\nexport * from './TaskOption';\r\nexport * from './ITaskLoader';\r\nexport * from './LoaderFactory';\r\nexport * from './loaders/BaseLoader';\r\n\r\nexport class Development {\r\n    /**\r\n     * global data.\r\n     * \r\n     * \r\n     * @private\r\n     * @type {*}\r\n     * @memberOf Development\r\n     */\r\n    private globals: any = {};\r\n    /**\r\n     * create development tool.\r\n     * \r\n     * @static\r\n     * @param {Gulp} gulp\r\n     * @param {string} dirname\r\n     * @param {(DevelopConfig | Array<ITaskOption | IAssertOption | IDynamicTaskOption>)} setting\r\n     * @param {any} [runWay=RunWay.sequence]\r\n     * @returns {Development}\r\n     * \r\n     * @memberOf Development\r\n     */\r\n    static create(gulp: Gulp, dirname: string, setting: DevelopConfig | Array<ITaskOption | IAssertOption | IDynamicTaskOption>, runWay = RunWay.sequence): Development {\r\n        let option = _.isArray(setting) ? { tasks: setting, runWay: runWay } : setting;\r\n        if (!_.isUndefined(option.runWay)) {\r\n            option.runWay = runWay;\r\n        }\r\n        let devtool = new Development(dirname, option);\r\n        option.setupTask = option.setupTask || 'build';\r\n        gulp.task(option.setupTask, (callback: TaskCallback) => {\r\n            var options: IEnvOption = minimist(process.argv.slice(2), {\r\n                string: 'env',\r\n                default: { env: process.env.NODE_ENV || 'development' }\r\n            });\r\n            return devtool.run(gulp, options);\r\n        });\r\n\r\n        gulp.task('default', () => {\r\n            gulp.start(option.setupTask);\r\n        });\r\n        return devtool;\r\n    }\r\n\r\n    /**\r\n     * Creates an instance of Development.\r\n     * \r\n     * @param {string} dirname\r\n     * @param {DevelopConfig} config\r\n     * \r\n     * @memberOf Development\r\n     */\r\n    private constructor(private dirname: string, protected config: DevelopConfig) {\r\n\r\n    }\r\n\r\n    /**\r\n     * run task.\r\n     * \r\n     * @param {Gulp} gulp\r\n     * @param {IEnvOption} env\r\n     * @returns {Promise<any>}\r\n     * \r\n     * @memberOf Development\r\n     */\r\n    run(gulp: Gulp, env: IEnvOption): Promise<any> {\r\n        if (!env.root) {\r\n            env.root = this.dirname;\r\n        }\r\n\r\n        if (env.help) {\r\n            console.log(chalk.grey('... main help  ...'));\r\n            this.printHelp(env.help);\r\n        }\r\n\r\n        let gbctx = this.getContext(env);\r\n        return this.loadTasks(gulp, this.config.tasks, gbctx)\r\n            .then(tseq => {\r\n                // console.log(chalk.grey('run sequenec tasks:'), tseq);\r\n                if (this.config.runWay === RunWay.parallel) {\r\n                    return runSequence(gulp, [flattenSequence(gulp, tseq, gbctx)]);\r\n                } else {\r\n                    return runSequence(gulp, tseq);\r\n                }\r\n            })\r\n            .catch(err => {\r\n                console.error(err);\r\n                process.exit(1);\r\n            });\r\n    }\r\n\r\n    private globalctx: IContext;\r\n    getContext(env) {\r\n        if (!this.globalctx || this.globalctx.env !== env) {\r\n            let option = this.config.option || {};\r\n            this.globalctx = <IContext>this.bindingContext(bindingConfig({\r\n                env: env,\r\n                option: option\r\n            }), null);\r\n        }\r\n\r\n        return this.globalctx;\r\n    }\r\n\r\n    private bindingContext(context: ITaskContext, parent: IContext): IContext {\r\n        let ctx = <IContext>context;\r\n        // cfg.env = cfg.env || this.env;\r\n        ctx.globals = this.globals;\r\n        ctx.parent = _.isUndefined(parent) ? this.getContext(ctx.env) : parent;\r\n        return ctx;\r\n    }\r\n\r\n    protected loadTasks(gulp: Gulp, tasks: TaskOption, parent: IContext): Promise<Src[]> {\r\n        return Promise.all<Src[]>(\r\n            _.map(_.isArray(tasks) ? <ITaskOption[]>tasks : [<ITaskOption>tasks], optask => {\r\n                optask.dist = optask.dist || 'dist';\r\n                // console.log(chalk.grey('begin load task via loader:'), optask.loader);\r\n                let loader = this.createLoader(optask, parent.env);\r\n\r\n                return loader.loadContext(parent.env)\r\n                    .then(ctx => {\r\n                        this.bindingContext(ctx, parent);\r\n                        console.log(chalk.green('task context loaded.'));\r\n                        if (ctx.env.help) {\r\n                            if (ctx.printHelp) {\r\n                                console.log(chalk.grey('...development default help...'));\r\n                                ctx.printHelp(_.isString(ctx.env.help) ? ctx.env.help : '');\r\n                            }\r\n                            return [];\r\n                        } else {\r\n                            return Promise.all([\r\n                                loader.load(ctx),\r\n                                this.loadAssertTasks(gulp, ctx),\r\n                                this.loadSubTask(gulp, ctx)\r\n                            ])\r\n                                .then(tks => {\r\n                                    console.log(chalk.green('tasks loaded.'));\r\n                                    return this.setup(gulp, ctx, tks[0], tks[1], tks[2]);\r\n                                });\r\n                        }\r\n                    });\r\n            })\r\n        ).then(tsq => {\r\n            return _.flatten(tsq);\r\n        });\r\n    }\r\n\r\n    protected setup(gulp: Gulp, ctx: ITaskContext, tasks: ITask[], assertsTask: ITaskInfo, subGroupTask: ITaskInfo): Promise<Src[]> {\r\n        return Promise.resolve(toSequence(gulp, tasks, ctx))\r\n            .then(tsqs => {\r\n                // if (_.isFunction(context.option['runTasks'])) {\r\n                //     return context.option['runTasks'](context.oper, tsqs, subGroupTask, assertsTask);\r\n                // } else if (_.isArray(context.option['runTasks'])) {\r\n                //     tsqs = context.option['runTasks'];\r\n                // } else \r\n                if (ctx.runTasks) {\r\n                    return ctx.runTasks(tsqs, assertsTask, subGroupTask);\r\n                }\r\n                // console.log(assertsTask);\r\n                ctx.addToSequence(tsqs, assertsTask);\r\n                ctx.addToSequence(tsqs, subGroupTask);\r\n\r\n                return tsqs;\r\n            });\r\n    }\r\n\r\n    /**\r\n     * load sub tasks as group task.\r\n     * \r\n     * @protected\r\n     * @param {Gulp} gulp\r\n     * @param {IContext} ctx\r\n     * @returns {Promise<ITaskInfo>}\r\n     * \r\n     * @memberOf Development\r\n     */\r\n    protected loadSubTask(gulp: Gulp, ctx: IContext): Promise<ITaskInfo> {\r\n        if (ctx.option['tasks']) {\r\n            let optask = <ITaskOption>ctx.option;\r\n            _.each(_.isArray(optask.tasks) ? optask.tasks : [optask.tasks], subopt => {\r\n                subopt.name = ctx.subTaskName(subopt.name);\r\n                subopt.src = subopt.src || optask.src;\r\n                subopt.dist = subopt.dist || optask.dist;\r\n            });\r\n            return this.loadTasks(gulp, optask.tasks, ctx)\r\n                .then(subseq => {\r\n\r\n                    let taskname = zipSequence(gulp, subseq, ctx, (name, runway) => name + (runway === RunWay.sequence ? '-sub-seq' : '-sub-par'));\r\n\r\n                    if (taskname) {\r\n                        return <ITaskInfo>{\r\n                            name: taskname,\r\n                            order: optask.subTaskOrder,\r\n                            taskName: taskname\r\n                        };\r\n                    } else {\r\n                        return null;\r\n                    }\r\n                });\r\n        } else {\r\n            return Promise.resolve(null);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * load asserts tasks.\r\n     * \r\n     * @protected\r\n     * @param {Gulp} gulp\r\n     * @param {ITaskContext} ctx\r\n     * @returns {Promise<Src>}\r\n     * \r\n     * @memberOf Development\r\n     */\r\n    protected loadAssertTasks(gulp: Gulp, ctx: IContext): Promise<ITaskInfo> {\r\n        let optask = <IAssertOption>ctx.option;\r\n        if (optask.asserts) {\r\n            let tasks: IAssertOption[] = [];\r\n            _.each(_.keys(optask.asserts), name => {\r\n                let op: IAssertOption;\r\n                let sr = optask.asserts[name];\r\n                if (_.isString(sr)) {\r\n                    op = <IAssertOption>{ src: sr, loader: [{ name: name, pipes: [], watch: true }] };\r\n                } else if (_.isArray(sr)) {\r\n                    if (sr.length > 0) {\r\n                        if (_.isString(_.first(<string[]>sr))) {\r\n                            op = <IAssertOption>{ src: <string[]>sr, loader: [{ name: name, pipes: [], watch: true }] };\r\n                        } else {\r\n                            op = <IAssertOption>{ loader: <IDynamicTaskOption[]>sr, watch: true };\r\n                        }\r\n                    }\r\n                } else if (_.isFunction(sr)) {\r\n                    op = { loader: sr };\r\n                } else {\r\n                    op = sr;\r\n                }\r\n\r\n                if (_.isNull(op) || _.isUndefined(op)) {\r\n                    return;\r\n                }\r\n                op.name = op.name || ctx.subTaskName(name);\r\n                op.src = op.src || (ctx.getSrc({ oper: Operation.build }) + '/**/*.' + name);\r\n                op.dist = op.dist || ctx.getDist({ oper: Operation.build });\r\n                tasks.push(op);\r\n            });\r\n\r\n            return Promise.all(_.map(tasks, task => {\r\n                return this.loadTasks(gulp, <ITaskOption>task, ctx)\r\n                    .then(sq => {\r\n                        return {\r\n                            task: task,\r\n                            sq: sq\r\n                        }\r\n                    });\r\n            }))\r\n                .then(tseq => {\r\n                    // asserts tasks run mutil.\r\n                    let assertSeq = _.map(tseq, t => {\r\n                        return zipSequence(gulp, t.sq, ctx, (name, runway) => ctx.subTaskName(name + (runway === RunWay.sequence ? '-assert-seq' : '-assert-par')));\r\n                    });\r\n\r\n\r\n                    return <ITaskInfo>{\r\n                        order: ctx.option.assertsOrder,\r\n                        taskName: assertSeq\r\n                    }\r\n                });\r\n        } else {\r\n            return Promise.resolve(null);\r\n        }\r\n    }\r\n\r\n    protected createLoader(option: TaskOption, env: IEnvOption): ITaskLoader {\r\n        let loader = null;\r\n        if (!_.isFunction(this.config.loaderFactory)) {\r\n            let factory = new LoaderFactory();\r\n            this.config.loaderFactory = (opt: ITaskOption) => {\r\n                return factory.create(opt, env);\r\n            }\r\n        }\r\n        loader = this.config.loaderFactory(option, env);\r\n        return loader;\r\n    }\r\n\r\n\r\n    protected printHelp(help: boolean | string) {\r\n        if (help === 'en') {\r\n\r\n            console.log(`\r\n                /**\r\n                 * gulp [build] [--env production|development] [--context name] [--root path] [--watch] [--test] [--serve] [--release] [--task taskname]\r\n                 * @params\r\n                 *  --env  development or production;\r\n                 *  --context app setting\r\n                 *  --root path, set relative path of the development tool root.\r\n                 *  --watch  watch src file change or not. if changed will auto update to node service. \r\n                 *  --release release web app or not. if [--env production], default to release. \r\n                 *  --test  need auto load test file to node service.\r\n                 *  --deploy run deploy tasks to deploy project.  \r\n                 *  --serve start node web service or not.\r\n                 *  --task taskname  spruce task taskname\r\n                 **/`);\r\n\r\n        } else {\r\n\r\n            console.log(`\r\n                /**\r\n                 * gulp [build] [--env production|development] [--context name] [--root path] [--watch] [--test] [--serve] [--release] [--task taskname]\r\n                 * @params\r\n                 *  --env 发布环境 默认开发环境development;\r\n                 *  --context 设置配置文件;\r\n                 *  --root path, 设置编译环境相对路径\r\n                 *  --watch  是否需要动态监听文件变化\r\n                 *  --release 是否release编译, [--env production] 默认release \r\n                 *  --test  启动自动化测试\r\n                 *  --deploy 运行加载deploy tasks, 编译发布项目。  \r\n                 *  --serve  是否在开发模式下 开启node web服务\r\n                 *  --task taskname  运行单独任务taskname\r\n                 **/`);\r\n\r\n        }\r\n    }\r\n}\r\n\r\n\r\n\r\n\r\n"]}