{"version":3,"sources":["tools.js","tools.ts"],"names":["__export","m","p","exports","hasOwnProperty","_","require","minimist","LoaderFactory_1","development_core_1","chalk","Development","dirname","option","_classCallCheck","this","globals","gulp","env","root","help","console","log","grey","printHelp","loadTasks","tasks","then","tseq","runSequence","catch","err","error","process","exit","ctx","_this","Promise","all","map","isArray","optask","dist","loader","createLoader","loadContext","bindingContext","green","isString","loadSubTask","subtask","load","loadAssertTasks","setup","tsq","flatten","assertsTask","subGroupTask","resolve","toSequence","tsqs","runTasks","addToSequence","_this2","_ret","each","subopt","name","subTaskName","src","v","subseq","length","first","last","frn","lsn","subName","task","order","subTaskOrder","taskName","_typeof","_this3","asserts","_ret2","keys","op","sr","pipes","watchTasks","isFunction","isNull","isUndefined","getSrc","oper","Operation","build","getDist","push","sq","assertSeq","t","assertsOrder","_this4","loaderFactory","factory","LoaderFactory","opt","create","setting","devtool","setupTask","callback","options","argv","slice","string","default","NODE_ENV","run","start"],"mappings":"AAAA,yHACA,QAASA,UAASC,GACd,IAAK,GAAIC,KAAKD,GAAQE,QAAQC,eAAeF,KAAIC,QAAQD,GAAKD,EAAEC,0dCFxDG,EAACC,QAAM,UAGPC,SAAQD,QAAM,YAE1BE,gBAAAF,QAA8B,mBAC9BG,mBAAAH,QAA2J,oBAE/II,MAAKJ,QAAM,QAKvBN,UAAAM,QAAc,oBACdN,SAAAM,QAAc,4BAEdK,wBAuCI,QAAAA,GAA4BC,EAA2BC,GAAqBC,gBAAAC,KAAAJ,GAAhDI,KAAAH,QAAAA,EAA2BG,KAAAF,OAAAA,EA9B/CE,KAAAC,4DAkCJC,EAAYC,GAUZ,MATKA,GAAIC,OACLD,EAAIC,KAAOJ,KAAKH,SAGhBM,EAAIE,OACJC,QAAQC,IAAIZ,MAAMa,KAAK,uBACvBR,KAAKS,UAAUN,EAAIE,OAGhBL,KAAKU,UAAUR,EAAMF,KAAKF,OAAOa,MAAOR,GAC1CS,KAAK,SAAAC,GAEF,MADAP,SAAQC,IAAIZ,MAAMa,KAAK,uBAAwBK,GACxCnB,mBAAAoB,YAAYZ,EAAMW,KAE5BE,MAAM,SAAAC,GACHV,QAAQW,MAAMD,GACdE,QAAQC,KAAK,4CAIFC,GAGnB,MADAA,GAAInB,QAAUD,KAAKC,QACZmB,oCAGSlB,EAAYS,EAAmBR,GAAe,GAAAkB,GAAArB,IAC9D,OAAOsB,SAAQC,IACXjC,EAAEkC,IAAIlC,EAAEmC,QAAQd,GAAwBA,GAAsBA,GAAQ,SAAAe,GAClEA,EAAOC,KAAOD,EAAOC,MAAQ,MAE7B,IAAIC,GAASP,EAAKQ,aAAaH,EAAQvB,EAEvC,OAAOyB,GAAOE,YAAY3B,GACrBS,KAAK,SAAAQ,GAGF,MAFAC,GAAKU,eAAeX,GACpBd,QAAQC,IAAIZ,MAAMqC,MAAM,yBACpBZ,EAAIjB,IAAIE,MACJe,EAAIX,YACJH,QAAQC,IAAIZ,MAAMa,KAAK,mCACvBY,EAAIX,UAAUnB,EAAE2C,SAASb,EAAIjB,IAAIE,MAAQe,EAAIjB,IAAIE,KAAO,SAIrDgB,EAAKa,YAAYhC,EAAMkB,GACzBR,KAAK,SAAAuB,GACF,MAAOb,SAAQC,KACXK,EAAOQ,KAAKhB,GACZC,EAAKgB,gBAAgBnC,EAAMkB,KAE1BR,KAAK,SAAAD,GAEF,MADAL,SAAQC,IAAIZ,MAAMqC,MAAM,kBACjBX,EAAKiB,MAAMpC,EAAMkB,EAAKT,EAAM,GAAIA,EAAM,GAAIwB,YAMnFvB,KAAK,SAAA2B,GACH,MAAOjD,GAAEkD,QAAQD,mCAITrC,EAAYkB,EAAmBT,EAAgB8B,EAAwBC,GACnF,MAAOpB,SAAQqB,QAAQjD,mBAAAkD,WAAW1C,EAAMS,EAAOS,IAC1CR,KAAK,SAAAiC,GAMF,MAAIzB,GAAI0B,SACG1B,EAAI0B,SAASD,EAAMJ,EAAaC,IAG3CtB,EAAI2B,cAAcF,EAAMJ,GACxBrB,EAAI2B,cAAcF,EAAMH,GAEjBG,yCAcG3C,EAAYkB,GAAiB,GAAA4B,GAAAhD,IAE/C,KAAIoB,EAAA,MA6BA,MAAOE,SAAQqB,QAAQ,KA7BT,IAAAM,GAAA,WACd,GAAIvB,GAAsBN,EAAItB,MAM9B,OALAR,GAAE4D,KAAK5D,EAAEmC,QAAQC,EAAOf,OAASe,EAAOf,OAASe,EAAOf,OAAQ,SAAAwC,GAC5DA,EAAOC,KAAOhC,EAAIiC,YAAYF,EAAOC,MACrCD,EAAOG,IAAMH,EAAOG,KAAO5B,EAAO4B,IAClCH,EAAOxB,KAAOwB,EAAOxB,MAAQD,EAAOC,QAExC4B,EAAOP,EAAKtC,UAAUR,EAAMwB,EAAOf,MAAOS,EAAIjB,KACzCS,KAAK,SAAA4C,GACF,GAAIA,GAAUA,EAAOC,OAAS,EAAG,CAC7B,GAAIC,GAAQpE,EAAEoE,MAAMF,GAChBG,EAAOrE,EAAEqE,KAAKH,GACdI,EAAMtE,EAAEmC,QAAQiC,GAASpE,EAAEoE,MAAMA,GAASA,EAC1CG,EAAMvE,EAAEmC,QAAQkC,GAAQrE,EAAEqE,KAAKA,GAAQA,EAEvCG,EAAU1C,EAAIiC,YAAeO,EAAnB,IAA0BC,EAAO,OAK/C,OAJA3D,GAAK6D,KAAKD,EAAS,WACf,MAAOpE,oBAAAoB,YAAYZ,EAAMsD,MAIzBQ,MAAOtC,EAAOuC,aACdC,SAAUJ,GAGd,MAAO,WAzBL,OAAA,YAAA,mBAAAb,GAAA,YAAAkB,QAAAlB,IAAAA,EAAAM,EAAA,+CA2CIrD,EAAYkB,GAAiB,GAAAgD,GAAApE,KAC/C0B,EAASN,EAAItB,MACjB,KAAIsB,EAAItB,OAAOuE,QAkEX,MAAO/C,SAAQqB,QAAQ,KAlEH,IAAA2B,GAAA,WACpB,GAAI3D,KA4BJ,OA3BArB,GAAE4D,KAAK5D,EAAEiF,KAAK7C,EAAO2C,SAAU,SAAAjB,GAC3B,GAAIoB,GAAAA,OACAC,EAAK/C,EAAO2C,QAAQjB,EACpB9D,GAAE2C,SAASwC,GACXD,GAAiBlB,IAAKmB,EAAI7C,SAAWwB,KAAMA,EAAMsB,WAAetB,KAASA,EAAT,SAAuBuB,YAAavB,MAC7F9D,EAAEmC,QAAQgD,GACbA,EAAGhB,OAAS,IAERe,EADAlF,EAAE2C,SAAS3C,EAAEoE,MAAgBe,KACZnB,IAAemB,EAAI7C,SAAWwB,KAAMA,EAAMsB,WAAetB,KAASA,EAAT,SAAuBuB,YAAavB,OAE7FxB,OAA8B6C,IAIvDD,EADOlF,EAAEsF,WAAWH,IACb7C,OAAQ6C,GAEVA,EAELnF,EAAEuF,OAAOL,IAAOlF,EAAEwF,YAAYN,KAGlCA,EAAGpB,KAAOhC,EAAIiC,YAAYD,EAAM,WAChCoB,EAAGlB,IAAMkB,EAAGlB,KAAQlC,EAAI2D,QAASC,KAAMtF,mBAAAuF,UAAUC,QAAW,SAAW9B,EACvEoB,EAAG7C,KAAO6C,EAAG7C,MAAQP,EAAI+D,SAAUH,KAAMtF,mBAAAuF,UAAUC,QACnDvE,EAAMyE,KAAKZ,OAGfjB,EAAOjC,QAAQC,IAAIjC,EAAEkC,IAAIb,EAAO,SAAAoD,GAC5B,MAAOK,GAAK1D,UAAUR,EAAmB6D,EAAM3C,EAAIjB,KAC9CS,KAAK,SAAAyE,GACF,OACItB,KAAMA,EACNsB,GAAIA,QAIfzE,KAAK,SAAAC,GAEF,GAAIyE,GAAYhG,EAAEkC,IAAIX,EAAM,SAAA0E,GACxB,GAAI/B,GAAS+B,EAAEF,GACXjC,EAAAA,MACJ,IAAII,GAAUA,EAAOC,OAAS,EAAG,CAC7B,GAAsB,IAAlBD,EAAOC,OACP,MAAOD,GAAO,EAGlBJ,GAAOhC,EAAIiC,YAAYkC,EAAExB,MACzB7D,EAAK6D,KAAKX,EAAM,WACZ,MAAO1D,oBAAAoB,YAAYZ,EAAMsD,SAG7BJ,GAAOhC,EAAIiC,YAAYkC,EAAEF,GAG7B,OAAOjC,IAIX,QACIY,MAAO5C,EAAItB,OAAO0F,aAClBtB,SAAUoB,QA9DF,OAAA,YAAA,mBAAAhB,GAAA,YAAAH,QAAAG,IAAAA,EAAAf,EAAA,4CAsELzD,EAAqBK,GAAe,GAAAsF,GAAAzF,KACnD4B,EAAS,IAQb,OAPKtC,GAAEsF,WAAW5E,KAAKF,OAAO4F,iBAAgB,WAC1C,GAAIC,GAAU,GAAIlG,iBAAAmG,aAClBH,GAAK3F,OAAO4F,cAAgB,SAACG,GACzB,MAAOF,GAAQG,OAAOD,EAAK1F,OAGnCyB,EAAS5B,KAAKF,OAAO4F,cAAc5F,EAAQK,qCAK3BE,GACH,OAATA,EAEAC,QAAQC,IAAR,w2BAiBAD,QAAQC,IAAR,0sBAzQML,EAAYL,EAAiBkG,GACvC,GAAIjG,GAASR,EAAEmC,QAAQsE,IAAapF,MAAOoF,GAAYA,EACnDC,EAAU,GAAIpG,GAAYC,EAASC,EAavC,OAZAA,GAAOmG,UAAYnG,EAAOmG,WAAa,QACvC/F,EAAK6D,KAAKjE,EAAOmG,UAAW,SAACC,GACzB,GAAIC,GAAsB3G,SAAS0B,QAAQkF,KAAKC,MAAM,IAClDC,OAAQ,MACRC,SAAWpG,IAAKe,QAAQf,IAAIqG,UAAY,gBAE5C,OAAOR,GAAQS,IAAIvG,EAAMiG,KAG7BjG,EAAK6D,KAAK,UAAW,WACjB7D,EAAKwG,MAAM5G,EAAOmG,aAEfD,UApCF5G,SAAAQ,YAAWA","file":"../tools.js","sourcesContent":["\"use strict\";\nfunction __export(m) {\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\n}\nconst _ = require('lodash');\nconst minimist = require('minimist');\nconst LoaderFactory_1 = require('./LoaderFactory');\nconst development_core_1 = require('development-core');\nconst chalk = require('chalk');\n// export * from 'development-core';\n__export(require('./LoaderFactory'));\n__export(require('./loaders/BaseLoader'));\nclass Development {\n    constructor(dirname, option) {\n        this.dirname = dirname;\n        this.option = option;\n        /**\n         * global data.\n         *\n         *\n         * @private\n         * @type {*}\n         * @memberOf Development\n         */\n        this.globals = {};\n    }\n    /**\n     * create development tool.\n     *\n     * @static\n     * @param {Gulp} gulp\n     * @param {string} dirname\n     * @param {(DevelopConfig | ITaskOption[])} setting\n     * @returns {Development}\n     *\n     * @memberOf Development\n     */\n    static create(gulp, dirname, setting) {\n        let option = _.isArray(setting) ? { tasks: setting } : setting;\n        let devtool = new Development(dirname, option);\n        option.setupTask = option.setupTask || 'build';\n        gulp.task(option.setupTask, (callback) => {\n            var options = minimist(process.argv.slice(2), {\n                string: 'env',\n                default: { env: process.env.NODE_ENV || 'development' }\n            });\n            return devtool.run(gulp, options);\n        });\n        gulp.task('default', () => {\n            gulp.start(option.setupTask);\n        });\n        return devtool;\n    }\n    run(gulp, env) {\n        if (!env.root) {\n            env.root = this.dirname;\n        }\n        if (env.help) {\n            console.log(chalk.grey('... main help  ...'));\n            this.printHelp(env.help);\n        }\n        return this.loadTasks(gulp, this.option.tasks, env)\n            .then(tseq => {\n            console.log(chalk.grey('run sequenec tasks:'), tseq);\n            return development_core_1.runSequence(gulp, tseq);\n        })\n            .catch(err => {\n            console.error(err);\n            process.exit(1);\n        });\n    }\n    bindingContext(ctx) {\n        // cfg.env = cfg.env || this.env;\n        ctx.globals = this.globals;\n        return ctx;\n    }\n    loadTasks(gulp, tasks, env) {\n        return Promise.all(_.map(_.isArray(tasks) ? tasks : [tasks], optask => {\n            optask.dist = optask.dist || 'dist';\n            // console.log(chalk.grey('begin load task via loader:'), optask.loader);\n            let loader = this.createLoader(optask, env);\n            return loader.loadContext(env)\n                .then(ctx => {\n                this.bindingContext(ctx);\n                console.log(chalk.green('task context loaded.'));\n                if (ctx.env.help) {\n                    if (ctx.printHelp) {\n                        console.log(chalk.grey('...development default help...'));\n                        ctx.printHelp(_.isString(ctx.env.help) ? ctx.env.help : '');\n                    }\n                    return [];\n                }\n                else {\n                    return this.loadSubTask(gulp, ctx)\n                        .then(subtask => {\n                        return Promise.all([\n                            loader.load(ctx),\n                            this.loadAssertTasks(gulp, ctx)\n                        ])\n                            .then(tasks => {\n                            console.log(chalk.green('tasks loaded.'));\n                            return this.setup(gulp, ctx, tasks[0], tasks[1], subtask);\n                        });\n                    });\n                }\n            });\n        })).then(tsq => {\n            return _.flatten(tsq);\n        });\n    }\n    setup(gulp, ctx, tasks, assertsTask, subGroupTask) {\n        return Promise.resolve(development_core_1.toSequence(gulp, tasks, ctx))\n            .then(tsqs => {\n            // if (_.isFunction(context.option['runTasks'])) {\n            //     return context.option['runTasks'](context.oper, tsqs, subGroupTask, assertsTask);\n            // } else if (_.isArray(context.option['runTasks'])) {\n            //     tsqs = context.option['runTasks'];\n            // } else \n            if (ctx.runTasks) {\n                return ctx.runTasks(tsqs, assertsTask, subGroupTask);\n            }\n            // console.log(assertsTask);\n            ctx.addToSequence(tsqs, assertsTask);\n            ctx.addToSequence(tsqs, subGroupTask);\n            return tsqs;\n        });\n    }\n    /**\n     * load sub tasks as group task.\n     *\n     * @protected\n     * @param {Gulp} gulp\n     * @param {ITaskContext} ctx\n     * @returns {Promise<Src>}\n     *\n     * @memberOf Development\n     */\n    loadSubTask(gulp, ctx) {\n        if (ctx['tasks']) {\n            let optask = ctx.option;\n            _.each(_.isArray(optask.tasks) ? optask.tasks : [optask.tasks], subopt => {\n                subopt.name = ctx.subTaskName(subopt.name);\n                subopt.src = subopt.src || optask.src;\n                subopt.dist = subopt.dist || optask.dist;\n            });\n            return this.loadTasks(gulp, optask.tasks, ctx.env)\n                .then(subseq => {\n                if (subseq && subseq.length > 0) {\n                    let first = _.first(subseq);\n                    let last = _.last(subseq);\n                    let frn = _.isArray(first) ? _.first(first) : first;\n                    let lsn = _.isArray(last) ? _.last(last) : last;\n                    let subName = ctx.subTaskName(`${frn}-${lsn}`, '-sub');\n                    gulp.task(subName, () => {\n                        return development_core_1.runSequence(gulp, subseq);\n                    });\n                    return {\n                        order: optask.subTaskOrder,\n                        taskName: subName\n                    };\n                }\n                else {\n                    return null;\n                }\n            });\n        }\n        else {\n            return Promise.resolve(null);\n        }\n    }\n    /**\n     * load asserts tasks.\n     *\n     * @protected\n     * @param {Gulp} gulp\n     * @param {ITaskContext} ctx\n     * @returns {Promise<Src>}\n     *\n     * @memberOf Development\n     */\n    loadAssertTasks(gulp, ctx) {\n        let optask = ctx.option;\n        if (ctx.option.asserts) {\n            let tasks = [];\n            _.each(_.keys(optask.asserts), name => {\n                let op;\n                let sr = optask.asserts[name];\n                if (_.isString(sr)) {\n                    op = { src: sr, loader: [{ name: name, pipes: [] }, { name: `${name}-watch`, watchTasks: [name] }] };\n                }\n                else if (_.isArray(sr)) {\n                    if (sr.length > 0) {\n                        if (_.isString(_.first(sr))) {\n                            op = { src: sr, loader: [{ name: name, pipes: [] }, { name: `${name}-watch`, watchTasks: [name] }] };\n                        }\n                        else {\n                            op = { loader: sr };\n                        }\n                    }\n                }\n                else if (_.isFunction(sr)) {\n                    op = { loader: sr };\n                }\n                else {\n                    op = sr;\n                }\n                ;\n                if (_.isNull(op) || _.isUndefined(op)) {\n                    return;\n                }\n                op.name = ctx.subTaskName(name, '-assert');\n                op.src = op.src || (ctx.getSrc({ oper: development_core_1.Operation.build }) + '/**/*.' + name);\n                op.dist = op.dist || ctx.getDist({ oper: development_core_1.Operation.build });\n                tasks.push(op);\n            });\n            return Promise.all(_.map(tasks, task => {\n                return this.loadTasks(gulp, task, ctx.env)\n                    .then(sq => {\n                    return {\n                        task: task,\n                        sq: sq\n                    };\n                });\n            }))\n                .then(tseq => {\n                // asserts tasks run mutil.\n                let assertSeq = _.map(tseq, t => {\n                    let subseq = t.sq;\n                    let name;\n                    if (subseq && subseq.length > 0) {\n                        if (subseq.length === 1) {\n                            return subseq[0];\n                        }\n                        name = ctx.subTaskName(t.task);\n                        gulp.task(name, () => {\n                            return development_core_1.runSequence(gulp, subseq);\n                        });\n                    }\n                    else {\n                        name = ctx.subTaskName(t.sq);\n                    }\n                    return name;\n                });\n                return {\n                    order: ctx.option.assertsOrder,\n                    taskName: assertSeq\n                };\n            });\n        }\n        else {\n            return Promise.resolve(null);\n        }\n    }\n    createLoader(option, env) {\n        let loader = null;\n        if (!_.isFunction(this.option.loaderFactory)) {\n            let factory = new LoaderFactory_1.LoaderFactory();\n            this.option.loaderFactory = (opt) => {\n                return factory.create(opt, env);\n            };\n        }\n        loader = this.option.loaderFactory(option, env);\n        return loader;\n    }\n    printHelp(help) {\n        if (help === 'en') {\n            console.log(`\r\n                /**\r\n                 * gulp [build] [--env production|development] [--context name] [--root path] [--watch] [--test] [--serve] [--release] [--task taskname]\r\n                 * @params\r\n                 *  --env  development or production;\r\n                 *  --context app setting\r\n                 *  --root path, set relative path of the development tool root.\r\n                 *  --watch  watch src file change or not. if changed will auto update to node service. \r\n                 *  --release release web app or not. if [--env production], default to release. \r\n                 *  --test  need auto load test file to node service.\r\n                 *  --deploy run deploy tasks to deploy project.  \r\n                 *  --serve start node web service or not.\r\n                 *  --task taskname  spruce task taskname\r\n                 **/`);\n        }\n        else {\n            console.log(`\r\n                /**\r\n                 * gulp [build] [--env production|development] [--context name] [--root path] [--watch] [--test] [--serve] [--release] [--task taskname]\r\n                 * @params\r\n                 *  --env 发布环境 默认开发环境development;\r\n                 *  --context 设置配置文件;\r\n                 *  --root path, 设置编译环境相对路径\r\n                 *  --watch  是否需要动态监听文件变化\r\n                 *  --release 是否release编译, [--env production] 默认release \r\n                 *  --test  启动自动化测试\r\n                 *  --deploy 运行加载deploy tasks, 编译发布项目。  \r\n                 *  --serve  是否在开发模式下 开启node web服务\r\n                 *  --task taskname  运行单独任务taskname\r\n                 **/`);\n        }\n    }\n}\nexports.Development = Development;\n","import * as _ from 'lodash';\r\nimport { Gulp, TaskCallback } from 'gulp';\r\n\r\nimport * as minimist from 'minimist';\r\nimport { ITaskLoader } from './ITaskLoader';\r\nimport { LoaderFactory } from './LoaderFactory';\r\nimport { TaskOption, Operation, Src, toSequence, runSequence, ITaskContext, IAsserts, ITaskInfo, ITask, ITaskOption, IEnvOption, IDynamicTaskOption } from 'development-core';\r\nimport { DevelopConfig } from './DevelopConfig';\r\nimport * as chalk from 'chalk';\r\n\r\nexport * from './DevelopConfig';\r\n// export * from 'development-core';\r\nexport * from './ITaskLoader';\r\nexport * from './LoaderFactory';\r\nexport * from './loaders/BaseLoader';\r\n\r\nexport class Development {\r\n    /**\r\n     * global data.\r\n     * \r\n     * \r\n     * @private\r\n     * @type {*}\r\n     * @memberOf Development\r\n     */\r\n    private globals: any = {};\r\n    /**\r\n     * create development tool.\r\n     * \r\n     * @static\r\n     * @param {Gulp} gulp\r\n     * @param {string} dirname\r\n     * @param {(DevelopConfig | ITaskOption[])} setting\r\n     * @returns {Development}\r\n     * \r\n     * @memberOf Development\r\n     */\r\n    static create(gulp: Gulp, dirname: string, setting: DevelopConfig | ITaskOption[] | IAsserts[]): Development {\r\n        let option = _.isArray(setting) ? { tasks: setting } : setting;\r\n        let devtool = new Development(dirname, option);\r\n        option.setupTask = option.setupTask || 'build';\r\n        gulp.task(option.setupTask, (callback: TaskCallback) => {\r\n            var options: IEnvOption = minimist(process.argv.slice(2), {\r\n                string: 'env',\r\n                default: { env: process.env.NODE_ENV || 'development' }\r\n            });\r\n            return devtool.run(gulp, options);\r\n        });\r\n\r\n        gulp.task('default', () => {\r\n            gulp.start(option.setupTask);\r\n        });\r\n        return devtool;\r\n    }\r\n\r\n    private constructor(private dirname: string, protected option: DevelopConfig) {\r\n\r\n    }\r\n\r\n    run(gulp: Gulp, env: IEnvOption): Promise<any> {\r\n        if (!env.root) {\r\n            env.root = this.dirname;\r\n        }\r\n\r\n        if (env.help) {\r\n            console.log(chalk.grey('... main help  ...'));\r\n            this.printHelp(env.help);\r\n        }\r\n\r\n        return this.loadTasks(gulp, this.option.tasks, env)\r\n            .then(tseq => {\r\n                console.log(chalk.grey('run sequenec tasks:'), tseq);\r\n                return runSequence(gulp, tseq);\r\n            })\r\n            .catch(err => {\r\n                console.error(err);\r\n                process.exit(1);\r\n            });\r\n    }\r\n\r\n    private bindingContext(ctx: ITaskContext): ITaskContext {\r\n        // cfg.env = cfg.env || this.env;\r\n        ctx.globals = this.globals;\r\n        return ctx;\r\n    }\r\n\r\n    protected loadTasks(gulp: Gulp, tasks: TaskOption, env: IEnvOption): Promise<Src[]> {\r\n        return Promise.all<Src[]>(\r\n            _.map(_.isArray(tasks) ? <ITaskOption[]>tasks : [<ITaskOption>tasks], optask => {\r\n                optask.dist = optask.dist || 'dist';\r\n                // console.log(chalk.grey('begin load task via loader:'), optask.loader);\r\n                let loader = this.createLoader(optask, env);\r\n\r\n                return loader.loadContext(env)\r\n                    .then(ctx => {\r\n                        this.bindingContext(ctx);\r\n                        console.log(chalk.green('task context loaded.'));\r\n                        if (ctx.env.help) {\r\n                            if (ctx.printHelp) {\r\n                                console.log(chalk.grey('...development default help...'));\r\n                                ctx.printHelp(_.isString(ctx.env.help) ? ctx.env.help : '');\r\n                            }\r\n                            return [];\r\n                        } else {\r\n                            return this.loadSubTask(gulp, ctx)\r\n                                .then(subtask => {\r\n                                    return Promise.all([\r\n                                        loader.load(ctx),\r\n                                        this.loadAssertTasks(gulp, ctx)\r\n                                    ])\r\n                                        .then(tasks => {\r\n                                            console.log(chalk.green('tasks loaded.'));\r\n                                            return this.setup(gulp, ctx, tasks[0], tasks[1], subtask)\r\n                                        });\r\n                                });\r\n                        }\r\n                    });\r\n            })\r\n        ).then(tsq => {\r\n            return _.flatten(tsq);\r\n        });\r\n    }\r\n\r\n    protected setup(gulp: Gulp, ctx: ITaskContext, tasks: ITask[], assertsTask: ITaskInfo, subGroupTask: ITaskInfo): Promise<Src[]> {\r\n        return Promise.resolve(toSequence(gulp, tasks, ctx))\r\n            .then(tsqs => {\r\n                // if (_.isFunction(context.option['runTasks'])) {\r\n                //     return context.option['runTasks'](context.oper, tsqs, subGroupTask, assertsTask);\r\n                // } else if (_.isArray(context.option['runTasks'])) {\r\n                //     tsqs = context.option['runTasks'];\r\n                // } else \r\n                if (ctx.runTasks) {\r\n                    return ctx.runTasks(tsqs, assertsTask, subGroupTask);\r\n                }\r\n                // console.log(assertsTask);\r\n                ctx.addToSequence(tsqs, assertsTask);\r\n                ctx.addToSequence(tsqs, subGroupTask);\r\n\r\n                return tsqs;\r\n            });\r\n    }\r\n\r\n    /**\r\n     * load sub tasks as group task.\r\n     * \r\n     * @protected\r\n     * @param {Gulp} gulp\r\n     * @param {ITaskContext} ctx\r\n     * @returns {Promise<Src>}\r\n     * \r\n     * @memberOf Development\r\n     */\r\n    protected loadSubTask(gulp: Gulp, ctx: ITaskContext): Promise<ITaskInfo> {\r\n\r\n        if (ctx['tasks']) {\r\n            let optask = <ITaskOption>ctx.option;\r\n            _.each(_.isArray(optask.tasks) ? optask.tasks : [optask.tasks], subopt => {\r\n                subopt.name = ctx.subTaskName(subopt.name);\r\n                subopt.src = subopt.src || optask.src;\r\n                subopt.dist = subopt.dist || optask.dist;\r\n            });\r\n            return this.loadTasks(gulp, optask.tasks, ctx.env)\r\n                .then(subseq => {\r\n                    if (subseq && subseq.length > 0) {\r\n                        let first = _.first(subseq);\r\n                        let last = _.last(subseq);\r\n                        let frn = _.isArray(first) ? _.first(first) : first;\r\n                        let lsn = _.isArray(last) ? _.last(last) : last;\r\n\r\n                        let subName = ctx.subTaskName(`${frn}-${lsn}`, '-sub');\r\n                        gulp.task(subName, () => {\r\n                            return runSequence(gulp, subseq);\r\n                        });\r\n\r\n                        return <ITaskInfo>{\r\n                            order: optask.subTaskOrder,\r\n                            taskName: subName\r\n                        };\r\n                    } else {\r\n                        return null;\r\n                    }\r\n                });\r\n        } else {\r\n            return Promise.resolve(null);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * load asserts tasks.\r\n     * \r\n     * @protected\r\n     * @param {Gulp} gulp\r\n     * @param {ITaskContext} ctx\r\n     * @returns {Promise<Src>}\r\n     * \r\n     * @memberOf Development\r\n     */\r\n    protected loadAssertTasks(gulp: Gulp, ctx: ITaskContext): Promise<ITaskInfo> {\r\n        let optask = ctx.option;\r\n        if (ctx.option.asserts) {\r\n            let tasks: IAsserts[] = [];\r\n            _.each(_.keys(optask.asserts), name => {\r\n                let op: IAsserts;\r\n                let sr = optask.asserts[name];\r\n                if (_.isString(sr)) {\r\n                    op = <IAsserts>{ src: sr, loader: [{ name: name, pipes: [] }, { name: `${name}-watch`, watchTasks: [name] }] };\r\n                } else if (_.isArray(sr)) {\r\n                    if (sr.length > 0) {\r\n                        if (_.isString(_.first(<string[]>sr))) {\r\n                            op = <IAsserts>{ src: <string[]>sr, loader: [{ name: name, pipes: [] }, { name: `${name}-watch`, watchTasks: [name] }] };\r\n                        } else {\r\n                            op = <IAsserts>{ loader: <IDynamicTaskOption[]>sr };\r\n                        }\r\n                    }\r\n                } else if (_.isFunction(sr)) {\r\n                    op = { loader: sr };\r\n                } else {\r\n                    op = sr;\r\n                };\r\n                if (_.isNull(op) || _.isUndefined(op)) {\r\n                    return;\r\n                }\r\n                op.name = ctx.subTaskName(name, '-assert');\r\n                op.src = op.src || (ctx.getSrc({ oper: Operation.build }) + '/**/*.' + name);\r\n                op.dist = op.dist || ctx.getDist({ oper: Operation.build });\r\n                tasks.push(op);\r\n            });\r\n\r\n            return Promise.all(_.map(tasks, task => {\r\n                return this.loadTasks(gulp, <ITaskOption>task, ctx.env)\r\n                    .then(sq => {\r\n                        return {\r\n                            task: task,\r\n                            sq: sq\r\n                        }\r\n                    });\r\n            }))\r\n                .then(tseq => {\r\n                    // asserts tasks run mutil.\r\n                    let assertSeq = _.map(tseq, t => {\r\n                        let subseq = t.sq;\r\n                        let name;\r\n                        if (subseq && subseq.length > 0) {\r\n                            if (subseq.length === 1) {\r\n                                return subseq[0];\r\n                            }\r\n\r\n                            name = ctx.subTaskName(t.task)\r\n                            gulp.task(name, () => {\r\n                                return runSequence(gulp, subseq);\r\n                            });\r\n                        } else {\r\n                            name = ctx.subTaskName(t.sq);\r\n                        }\r\n\r\n                        return name;\r\n                    });\r\n\r\n\r\n                    return <ITaskInfo>{\r\n                        order: ctx.option.assertsOrder,\r\n                        taskName: assertSeq\r\n                    }\r\n                });\r\n        } else {\r\n            return Promise.resolve(null);\r\n        }\r\n    }\r\n\r\n    protected createLoader(option: ITaskOption, env: IEnvOption): ITaskLoader {\r\n        let loader = null;\r\n        if (!_.isFunction(this.option.loaderFactory)) {\r\n            let factory = new LoaderFactory();\r\n            this.option.loaderFactory = (opt: ITaskOption) => {\r\n                return factory.create(opt, env);\r\n            }\r\n        }\r\n        loader = this.option.loaderFactory(option, env);\r\n        return loader;\r\n    }\r\n\r\n\r\n    protected printHelp(help: boolean | string) {\r\n        if (help === 'en') {\r\n\r\n            console.log(`\r\n                /**\r\n                 * gulp [build] [--env production|development] [--context name] [--root path] [--watch] [--test] [--serve] [--release] [--task taskname]\r\n                 * @params\r\n                 *  --env  development or production;\r\n                 *  --context app setting\r\n                 *  --root path, set relative path of the development tool root.\r\n                 *  --watch  watch src file change or not. if changed will auto update to node service. \r\n                 *  --release release web app or not. if [--env production], default to release. \r\n                 *  --test  need auto load test file to node service.\r\n                 *  --deploy run deploy tasks to deploy project.  \r\n                 *  --serve start node web service or not.\r\n                 *  --task taskname  spruce task taskname\r\n                 **/`);\r\n\r\n        } else {\r\n\r\n            console.log(`\r\n                /**\r\n                 * gulp [build] [--env production|development] [--context name] [--root path] [--watch] [--test] [--serve] [--release] [--task taskname]\r\n                 * @params\r\n                 *  --env 发布环境 默认开发环境development;\r\n                 *  --context 设置配置文件;\r\n                 *  --root path, 设置编译环境相对路径\r\n                 *  --watch  是否需要动态监听文件变化\r\n                 *  --release 是否release编译, [--env production] 默认release \r\n                 *  --test  启动自动化测试\r\n                 *  --deploy 运行加载deploy tasks, 编译发布项目。  \r\n                 *  --serve  是否在开发模式下 开启node web服务\r\n                 *  --task taskname  运行单独任务taskname\r\n                 **/`);\r\n\r\n        }\r\n    }\r\n}\r\n\r\n\r\n\r\n\r\n"]}