{"version":3,"sources":["tools.js","tools.ts"],"names":["__export","m","p","exports","hasOwnProperty","_","require","minimist","LoaderFactory_1","development_core_1","chalk","Development","dirname","option","_classCallCheck","this","globals","gulp","env","root","help","console","log","grey","printHelp","loadTasks","tasks","then","tseq","runSequence","catch","err","error","cfg","_this","Promise","all","map","isArray","optask","dist","oper","currentOperation","loader","createLoader","loadConfg","green","isString","bindingConfig","loadSubTask","subtask","load","loadAssertTasks","setup","tsq","flatten","config","assertsTask","subGroupTask","resolve","toSequence","tsqs","runTasks","addToSequence","_this2","_ret","each","subopt","name","subTaskName","src","v","subseq","length","first","last","frn","lsn","subName","task","order","subTaskOrder","_typeof","_this3","asserts","_ret2","keys","op","aop","pipes","watch","some","it","isNull","isUndefined","push","sq","assertSeq","t","assertsOrder","_this4","isFunction","loaderFactory","factory","LoaderFactory","opt","create","setting","devtool","setupTask","callback","options","process","argv","slice","string","default","NODE_ENV","run","start"],"mappings":"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","file":"../tools.js","sourcesContent":["\"use strict\";\nfunction __export(m) {\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\n}\nconst _ = require('lodash');\nconst minimist = require('minimist');\nconst LoaderFactory_1 = require('./LoaderFactory');\nconst development_core_1 = require('development-core');\nconst chalk = require('chalk');\n__export(require('./LoaderFactory'));\n__export(require('./loaders/BaseLoader'));\nclass Development {\n    constructor(dirname, option) {\n        this.dirname = dirname;\n        this.option = option;\n        this.globals = {};\n    }\n    static create(gulp, dirname, setting) {\n        let option = _.isArray(setting) ? { tasks: setting } : setting;\n        let devtool = new Development(dirname, option);\n        option.setupTask = option.setupTask || 'build';\n        gulp.task(option.setupTask, (callback) => {\n            var options = minimist(process.argv.slice(2), {\n                string: 'env',\n                default: { env: process.env.NODE_ENV || 'development' }\n            });\n            return devtool.run(gulp, options);\n        });\n        gulp.task('default', () => {\n            gulp.start(option.setupTask);\n        });\n        return devtool;\n    }\n    run(gulp, env) {\n        if (!env.root) {\n            env.root = this.dirname;\n        }\n        if (env.help) {\n            console.log(chalk.grey('... main help  ...'));\n            this.printHelp(env.help);\n        }\n        return this.loadTasks(gulp, this.option.tasks, env)\n            .then(tseq => {\n            console.log(chalk.grey('run sequenec tasks:'), tseq);\n            return development_core_1.runSequence(gulp, tseq);\n        })\n            .catch(err => {\n            console.error(err);\n        });\n    }\n    bindingConfig(cfg) {\n        cfg.globals = this.globals;\n        return cfg;\n    }\n    loadTasks(gulp, tasks, env) {\n        return Promise.all(_.map(_.isArray(tasks) ? tasks : [tasks], optask => {\n            optask.dist = optask.dist || 'dist';\n            let oper = development_core_1.currentOperation(env);\n            console.log(chalk.grey('begin load task via loader:'), optask.loader);\n            let loader = this.createLoader(optask);\n            return loader.loadConfg(oper, env)\n                .then(cfg => {\n                console.log(chalk.green('task config loaded.'));\n                if (cfg.env.help) {\n                    if (cfg.printHelp) {\n                        console.log(chalk.grey('...development default help...'));\n                        cfg.printHelp(_.isString(cfg.env.help) ? cfg.env.help : '');\n                    }\n                    return [];\n                }\n                else {\n                    cfg = this.bindingConfig(cfg);\n                    return this.loadSubTask(gulp, cfg)\n                        .then(subtask => {\n                        return Promise.all([\n                            loader.load(cfg),\n                            this.loadAssertTasks(gulp, cfg)\n                        ])\n                            .then(tasks => {\n                            console.log(chalk.green('tasks loaded.'));\n                            return this.setup(gulp, cfg, tasks[0], tasks[1], subtask);\n                        });\n                    });\n                }\n            });\n        })).then(tsq => {\n            return _.flatten(tsq);\n        });\n    }\n    setup(gulp, config, tasks, assertsTask, subGroupTask) {\n        return Promise.resolve(development_core_1.toSequence(gulp, tasks, config))\n            .then(tsqs => {\n            if (config.runTasks) {\n                return config.runTasks(tsqs, assertsTask, subGroupTask);\n            }\n            config.addToSequence(tsqs, assertsTask);\n            config.addToSequence(tsqs, subGroupTask);\n            return tsqs;\n        });\n    }\n    loadSubTask(gulp, config) {\n        if (config['tasks']) {\n            let optask = config.option;\n            _.each(_.isArray(optask.tasks) ? optask.tasks : [optask.tasks], subopt => {\n                subopt.name = config.subTaskName(subopt.name);\n                subopt.src = subopt.src || optask.src;\n                subopt.dist = subopt.dist || optask.dist;\n            });\n            return this.loadTasks(gulp, optask.tasks, config.env)\n                .then(subseq => {\n                if (subseq && subseq.length > 0) {\n                    let first = _.first(subseq);\n                    let last = _.last(subseq);\n                    let frn = _.isArray(first) ? _.first(first) : first;\n                    let lsn = _.isArray(last) ? _.last(last) : last;\n                    let subName = config.subTaskName(`${frn}-${lsn}`, '-sub');\n                    gulp.task(subName, () => {\n                        return development_core_1.runSequence(gulp, subseq);\n                    });\n                    return {\n                        order: optask.subTaskOrder,\n                        name: subName\n                    };\n                }\n                else {\n                    return null;\n                }\n            });\n        }\n        else {\n            return Promise.resolve(null);\n        }\n    }\n    loadAssertTasks(gulp, config) {\n        let optask = config.option;\n        if (config.option.asserts) {\n            let tasks = [];\n            _.each(_.keys(optask.asserts), name => {\n                let op;\n                let aop = optask.asserts[name];\n                if (_.isString(aop)) {\n                    op = { src: aop, loader: [{ name: name, pipes: [] }, { name: `${name}-watch`, watch: [name] }] };\n                }\n                else if (_.isArray(aop)) {\n                    if (_.some(aop, it => _.isString(aop))) {\n                        op = { src: aop, loader: [{ name: name, pipes: [] }, { name: `${name}-watch`, watch: [name] }] };\n                    }\n                    else {\n                        op = { loader: aop };\n                    }\n                }\n                else {\n                    op = aop;\n                }\n                ;\n                if (_.isNull(op) || _.isUndefined(op)) {\n                    return;\n                }\n                op.name = config.subTaskName(name, '-assert');\n                op.src = op.src || (optask.src + '/**/*.' + name);\n                op.dist = op.dist || optask.dist;\n                tasks.push(op);\n            });\n            return Promise.all(_.map(tasks, task => {\n                return this.loadTasks(gulp, task, config.env)\n                    .then(sq => {\n                    return {\n                        task: task,\n                        sq: sq\n                    };\n                });\n            }))\n                .then(tseq => {\n                let assertSeq = _.map(tseq, t => {\n                    let subseq = t.sq;\n                    let name;\n                    if (subseq && subseq.length > 0) {\n                        if (subseq.length === 1) {\n                            return subseq[0];\n                        }\n                        name = config.subTaskName(t.task);\n                        gulp.task(name, () => {\n                            return development_core_1.runSequence(gulp, subseq);\n                        });\n                    }\n                    else {\n                        name = config.subTaskName(t.sq);\n                    }\n                    return name;\n                });\n                return {\n                    order: config.option.assertsOrder,\n                    name: assertSeq\n                };\n            });\n        }\n        else {\n            return Promise.resolve(null);\n        }\n    }\n    createLoader(option) {\n        let loader = null;\n        if (!_.isFunction(this.option.loaderFactory)) {\n            let factory = new LoaderFactory_1.LoaderFactory();\n            this.option.loaderFactory = (opt) => {\n                return factory.create(opt);\n            };\n        }\n        loader = this.option.loaderFactory(option);\n        return loader;\n    }\n    printHelp(help) {\n        if (help === 'en') {\n            console.log(`\r\n                /**\r\n                 * gulp [build] [--env production|development] [--config name] [--root path] [--watch] [--test] [--serve] [--release] [--task taskname]\r\n                 * @params\r\n                 *  --env  development or production;\r\n                 *  --config app setting\r\n                 *  --root path, set relative path of the development tool root.\r\n                 *  --watch  watch src file change or not. if changed will auto update to node service. \r\n                 *  --release release web app or not. if [--env production], default to release. \r\n                 *  --test  need auto load test file to node service.\r\n                 *  --deploy run deploy tasks to deploy project.  \r\n                 *  --serve start node web service or not.\r\n                 *  --task taskname  spruce task taskname\r\n                 **/`);\n        }\n        else {\n            console.log(`\r\n                /**\r\n                 * gulp [build] [--env production|development] [--config name] [--root path] [--watch] [--test] [--serve] [--release] [--task taskname]\r\n                 * @params\r\n                 *  --env 发布环境 默认开发环境development;\r\n                 *  --config 设置配置文件;\r\n                 *  --root path, 设置编译环境相对路径\r\n                 *  --watch  是否需要动态监听文件变化\r\n                 *  --release 是否release编译, [--env production] 默认release \r\n                 *  --test  启动自动化测试\r\n                 *  --deploy 运行加载deploy tasks, 编译发布项目。  \r\n                 *  --serve  是否在开发模式下 开启node web服务\r\n                 *  --task taskname  运行单独任务taskname\r\n                 **/`);\n        }\n    }\n}\nexports.Development = Development;\n","import * as _ from 'lodash';\r\nimport { Gulp, TaskCallback } from 'gulp';\r\n\r\nimport * as minimist from 'minimist';\r\nimport { ITaskLoader } from './ITaskLoader';\r\nimport { LoaderFactory } from './LoaderFactory';\r\nimport {\r\n    Src, currentOperation, toSequence, runSequence\r\n    , IAsserts, ITaskInfo, ITask, ITaskOption, Operation, IEnvOption, ITaskConfig\r\n} from 'development-core';\r\nimport { DevelopConfig } from './DevelopConfig';\r\nimport * as chalk from 'chalk';\r\n\r\nexport * from './DevelopConfig';\r\n// export * from 'development-core';\r\nexport * from './ITaskLoader';\r\nexport * from './LoaderFactory';\r\nexport * from './loaders/BaseLoader';\r\n\r\nexport class Development {\r\n    /**\r\n     * global data.\r\n     * \r\n     * \r\n     * @private\r\n     * @type {*}\r\n     * @memberOf Development\r\n     */\r\n    private globals: any = {};\r\n    /**\r\n     * create development tool.\r\n     * \r\n     * @static\r\n     * @param {Gulp} gulp\r\n     * @param {string} dirname\r\n     * @param {(DevelopConfig | ITaskOption[])} setting\r\n     * @returns {Development}\r\n     * \r\n     * @memberOf Development\r\n     */\r\n    static create(gulp: Gulp, dirname: string, setting: DevelopConfig | ITaskOption[]): Development {\r\n        let option = _.isArray(setting) ? { tasks: setting } : setting;\r\n        let devtool = new Development(dirname, option);\r\n        option.setupTask = option.setupTask || 'build';\r\n        gulp.task(option.setupTask, (callback: TaskCallback) => {\r\n            var options: IEnvOption = minimist(process.argv.slice(2), {\r\n                string: 'env',\r\n                default: { env: process.env.NODE_ENV || 'development' }\r\n            });\r\n            return devtool.run(gulp, options);\r\n        });\r\n\r\n        gulp.task('default', () => {\r\n            gulp.start(option.setupTask);\r\n        });\r\n        return devtool;\r\n    }\r\n\r\n    private constructor(private dirname: string, protected option: DevelopConfig) {\r\n\r\n    }\r\n\r\n    run(gulp: Gulp, env: IEnvOption): Promise<any> {\r\n        if (!env.root) {\r\n            env.root = this.dirname;\r\n        }\r\n\r\n        if (env.help) {\r\n            console.log(chalk.grey('... main help  ...'));\r\n            this.printHelp(env.help);\r\n        }\r\n\r\n        return this.loadTasks(gulp, this.option.tasks, env)\r\n            .then(tseq => {\r\n                console.log(chalk.grey('run sequenec tasks:'), tseq);\r\n                return runSequence(gulp, tseq);\r\n            })\r\n            .catch(err => {\r\n                console.error(err);\r\n            });\r\n    }\r\n\r\n    private bindingConfig(cfg: ITaskConfig): ITaskConfig {\r\n        // cfg.env = cfg.env || this.env;\r\n        cfg.globals = this.globals;\r\n        return cfg;\r\n    }\r\n\r\n    protected loadTasks(gulp: Gulp, tasks: ITaskOption | ITaskOption[], env: IEnvOption): Promise<Src[]> {\r\n        return Promise.all<Src[]>(\r\n            _.map(_.isArray(tasks) ? <ITaskOption[]>tasks : [<ITaskOption>tasks], optask => {\r\n                optask.dist = optask.dist || 'dist';\r\n                let oper: Operation = currentOperation(env);\r\n\r\n                console.log(chalk.grey('begin load task via loader:'), optask.loader);\r\n                let loader = this.createLoader(optask);\r\n\r\n                return loader.loadConfg(oper, env)\r\n                    .then(cfg => {\r\n                        console.log(chalk.green('task config loaded.'));\r\n                        if (cfg.env.help) {\r\n                            if (cfg.printHelp) {\r\n                                console.log(chalk.grey('...development default help...'));\r\n                                cfg.printHelp(_.isString(cfg.env.help) ? cfg.env.help : '');\r\n                            }\r\n                            return [];\r\n                        } else {\r\n                            cfg = this.bindingConfig(cfg);\r\n                            return this.loadSubTask(gulp, cfg)\r\n                                .then(subtask => {\r\n                                    return Promise.all([\r\n                                        loader.load(cfg),\r\n                                        this.loadAssertTasks(gulp, cfg)\r\n                                    ])\r\n                                        .then(tasks => {\r\n                                            console.log(chalk.green('tasks loaded.'));\r\n                                            return this.setup(gulp, cfg, tasks[0], tasks[1], subtask)\r\n                                        });\r\n                                });\r\n                        }\r\n                    });\r\n            })\r\n        ).then(tsq => {\r\n            return _.flatten(tsq);\r\n        });\r\n    }\r\n\r\n    protected setup(gulp: Gulp, config: ITaskConfig, tasks: ITask[], assertsTask: ITaskInfo, subGroupTask: ITaskInfo): Promise<Src[]> {\r\n        return Promise.resolve(toSequence(gulp, tasks, config))\r\n            .then(tsqs => {\r\n                // if (_.isFunction(config.option['runTasks'])) {\r\n                //     return config.option['runTasks'](config.oper, tsqs, subGroupTask, assertsTask);\r\n                // } else if (_.isArray(config.option['runTasks'])) {\r\n                //     tsqs = config.option['runTasks'];\r\n                // } else \r\n                if (config.runTasks) {\r\n                    return config.runTasks(tsqs, assertsTask, subGroupTask);\r\n                }\r\n\r\n                config.addToSequence(tsqs, assertsTask);\r\n                config.addToSequence(tsqs, subGroupTask);\r\n\r\n                return tsqs;\r\n            });\r\n    }\r\n\r\n    /**\r\n     * load sub tasks as group task.\r\n     * \r\n     * @protected\r\n     * @param {Gulp} gulp\r\n     * @param {ITaskConfig} config\r\n     * @returns {Promise<Src>}\r\n     * \r\n     * @memberOf Development\r\n     */\r\n    protected loadSubTask(gulp: Gulp, config: ITaskConfig): Promise<ITaskInfo> {\r\n\r\n        if (config['tasks']) {\r\n            let optask = <ITaskOption>config.option;\r\n            _.each(_.isArray(optask.tasks) ? optask.tasks : [optask.tasks], subopt => {\r\n                subopt.name = config.subTaskName(subopt.name);\r\n                subopt.src = subopt.src || optask.src;\r\n                subopt.dist = subopt.dist || optask.dist;\r\n            });\r\n            return this.loadTasks(gulp, optask.tasks, config.env)\r\n                .then(subseq => {\r\n                    if (subseq && subseq.length > 0) {\r\n                        let first = _.first(subseq);\r\n                        let last = _.last(subseq);\r\n                        let frn = _.isArray(first) ? _.first(first) : first;\r\n                        let lsn = _.isArray(last) ? _.last(last) : last;\r\n\r\n                        let subName = config.subTaskName(`${frn}-${lsn}`, '-sub');\r\n                        gulp.task(subName, () => {\r\n                            return runSequence(gulp, subseq);\r\n                        });\r\n\r\n                        return <ITaskInfo>{\r\n                            order: optask.subTaskOrder,\r\n                            name: subName\r\n                        };\r\n                    } else {\r\n                        return null;\r\n                    }\r\n                });\r\n        } else {\r\n            return Promise.resolve(null);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * load asserts tasks.\r\n     * \r\n     * @protected\r\n     * @param {Gulp} gulp\r\n     * @param {ITaskConfig} config\r\n     * @returns {Promise<Src>}\r\n     * \r\n     * @memberOf Development\r\n     */\r\n    protected loadAssertTasks(gulp: Gulp, config: ITaskConfig): Promise<ITaskInfo> {\r\n        let optask = config.option;\r\n        if (config.option.asserts) {\r\n            let tasks: IAsserts[] = [];\r\n            _.each(_.keys(optask.asserts), name => {\r\n                let op: IAsserts;\r\n                let aop = optask.asserts[name];\r\n                if (_.isString(aop)) {\r\n                    op = <IAsserts>{ src: aop, loader: [{ name: name, pipes: [] }, { name: `${name}-watch`, watch: [name] }] };\r\n                } else if (_.isArray(aop)) {\r\n                    if (_.some(aop, it => _.isString(aop))) {\r\n                        op = <IAsserts>{ src: aop, loader: [{ name: name, pipes: [] }, { name: `${name}-watch`, watch: [name] }] };\r\n                    } else {\r\n                        op = <IAsserts>{ loader: aop };\r\n                    }\r\n                } else {\r\n                    op = aop;\r\n                };\r\n                if (_.isNull(op) || _.isUndefined(op)) {\r\n                    return;\r\n                }\r\n                op.name = config.subTaskName(name, '-assert');\r\n                op.src = op.src || (optask.src + '/**/*.' + name);\r\n                op.dist = op.dist || optask.dist;\r\n                tasks.push(op);\r\n            });\r\n\r\n            return Promise.all(_.map(tasks, task => {\r\n                return this.loadTasks(gulp, <ITaskOption>task, config.env)\r\n                    .then(sq => {\r\n                        return {\r\n                            task: task,\r\n                            sq: sq\r\n                        }\r\n                    });\r\n            }))\r\n                .then(tseq => {\r\n                    // asserts tasks run mutil.\r\n                    let assertSeq = _.map(tseq, t => {\r\n                        let subseq = t.sq;\r\n                        let name;\r\n                        if (subseq && subseq.length > 0) {\r\n                            if (subseq.length === 1) {\r\n                                return subseq[0];\r\n                            }\r\n\r\n                            name = config.subTaskName(t.task)\r\n                            gulp.task(name, () => {\r\n                                return runSequence(gulp, subseq);\r\n                            });\r\n                        } else {\r\n                            name = config.subTaskName(t.sq);\r\n                        }\r\n\r\n                        return name;\r\n                    });\r\n\r\n\r\n                    return <ITaskInfo>{\r\n                        order: config.option.assertsOrder,\r\n                        name: assertSeq\r\n                    }\r\n                });\r\n        } else {\r\n            return Promise.resolve(null);\r\n        }\r\n    }\r\n\r\n    protected createLoader(option: ITaskOption): ITaskLoader {\r\n        let loader = null;\r\n        if (!_.isFunction(this.option.loaderFactory)) {\r\n            let factory = new LoaderFactory();\r\n            this.option.loaderFactory = (opt: ITaskOption) => {\r\n                return factory.create(opt);\r\n            }\r\n        }\r\n        loader = this.option.loaderFactory(option);\r\n        return loader;\r\n    }\r\n\r\n\r\n    protected printHelp(help: boolean | string) {\r\n        if (help === 'en') {\r\n\r\n            console.log(`\r\n                /**\r\n                 * gulp [build] [--env production|development] [--config name] [--root path] [--watch] [--test] [--serve] [--release] [--task taskname]\r\n                 * @params\r\n                 *  --env  development or production;\r\n                 *  --config app setting\r\n                 *  --root path, set relative path of the development tool root.\r\n                 *  --watch  watch src file change or not. if changed will auto update to node service. \r\n                 *  --release release web app or not. if [--env production], default to release. \r\n                 *  --test  need auto load test file to node service.\r\n                 *  --deploy run deploy tasks to deploy project.  \r\n                 *  --serve start node web service or not.\r\n                 *  --task taskname  spruce task taskname\r\n                 **/`);\r\n\r\n        } else {\r\n\r\n            console.log(`\r\n                /**\r\n                 * gulp [build] [--env production|development] [--config name] [--root path] [--watch] [--test] [--serve] [--release] [--task taskname]\r\n                 * @params\r\n                 *  --env 发布环境 默认开发环境development;\r\n                 *  --config 设置配置文件;\r\n                 *  --root path, 设置编译环境相对路径\r\n                 *  --watch  是否需要动态监听文件变化\r\n                 *  --release 是否release编译, [--env production] 默认release \r\n                 *  --test  启动自动化测试\r\n                 *  --deploy 运行加载deploy tasks, 编译发布项目。  \r\n                 *  --serve  是否在开发模式下 开启node web服务\r\n                 *  --task taskname  运行单独任务taskname\r\n                 **/`);\r\n\r\n        }\r\n    }\r\n}\r\n\r\n\r\n\r\n\r\n"]}