{"version":3,"sources":["Development.js","Development.ts"],"names":["_","require","minimist","LoaderFactory_1","development_core_1","Context_1","chalk","events_1","Development","dirname","config","evnets","each","keys","on","key","gulp","env","setupTasks","then","tseq","task","split","seq","gbctx","getContext","emit","runWay","RunWay","parallel","runSequence","flattenSequence","catch","console","error","err","process","exit","root","help","log","grey","printHelp","loadTasks","tasks","tsq","setupTask","callback","options","argv","slice","string","default","NODE_ENV","run","startTask","Promise","reject","start","globalctx","option","contextFactory","parent","all","map","isArray","loader","createLoader","optask","loadContext","green","ctx","isString","load","loadAssertTasks","loadSubTask","tks","rst","tk","zipSequence","t","push","assertsTask","subGroupTask","resolve","toSequence","runTasks","tsqs","addToSequence","subopt","name","subTaskName","taskname","subTaskRunWay","subseq","runway","sequence","order","subTaskOrder","taskName","asserts","op","sr","src","pipes","watch","isNumber","oper","isFunction","length","first","isNull","isUndefined","getSrc","Operation","build","sq","assertSeq","assertsRunWay","assertsOrder","loaderFactory","factory","LoaderFactory","create","cfg","p","setting","Context","add","devtool","setup","EventEmitter","exports"],"mappings":"AAAA;;;;;;;;;;;;ACAA,IAAYA,IAACC,QAAM,QAAN,CAAb;AAGA,IAAYC,WAAQD,QAAM,UAAN,CAApB;AAEA,IAAAE,kBAAAF,QAA8B,iBAA9B,CAAA;AACA,IAAAG,qBAAAH,QAA0L,kBAA1L,CAAA;AAGA,IAAAI,YAAAJ,QAAwB,WAAxB,CAAA;AAEA,IAAYK,QAAKL,QAAM,OAAN,CAAjB;AACA,IAAAM,WAAAN,QAA6B,QAA7B,CAAA;;IAEAO,W;;;AAgCI;;;;;;;;AAQA,yBAA2BC,OAA3B,EAAsDC,MAAtD,EAA2E;AAAA;;AAAA;;AAAhD,cAAAD,OAAA,GAAAA,OAAA;AAA2B,cAAAC,MAAA,GAAAA,MAAA;AAElD,YAAIA,OAAOC,MAAX,EAAmB;AACfX,cAAEY,IAAF,CAAOZ,EAAEa,IAAF,CAAOH,OAAOC,MAAd,CAAP,EAA8B,eAAG;AAC7B,sBAAKG,EAAL,CAAQC,GAAR,EAAaL,OAAOC,MAAP,CAAcI,GAAd,CAAb;AACH,aAFD;AAGH;AANsE;AAO1E;AA7CD;;;;;;;;;;;;;;;;;AA+CA;;;;;;;;;4BASIC,I,EAAYC,G,EAAe;AAAA;;AAC3B,mBAAO,KAAKC,UAAL,CAAgBF,IAAhB,EAAsBC,GAAtB,EACFE,IADE,CACG,eAAG;AACL,oBAAIC,OAAOH,IAAII,IAAJ,GAAWJ,IAAII,IAAJ,CAASC,KAAT,CAAe,GAAf,CAAX,GAAiCC,GAA5C;AACA,oBAAIC,QAAQ,OAAKC,UAAL,CAAgBR,GAAhB,CAAZ;AACA,uBAAKS,IAAL,CAAU,UAAV,EAAsBN,IAAtB,EAA4BI,KAA5B;AACA,oBAAI,OAAKd,MAAL,CAAYiB,MAAZ,KAAuBvB,mBAAAwB,MAAA,CAAOC,QAAlC,EAA4C;AACxC,2BAAOzB,mBAAA0B,WAAA,CAAYd,IAAZ,EAAkB,CAACZ,mBAAA2B,eAAA,CAAgBf,IAAhB,EAAsBI,IAAtB,EAA4BI,KAA5B,CAAD,CAAlB,CAAP;AACH,iBAFD,MAEO;AACH,2BAAOpB,mBAAA0B,WAAA,CAAYd,IAAZ,EAAkBI,IAAlB,CAAP;AACH;AACJ,aAVE,EAWFD,IAXE,CAWG,YAAA;AACF,oBAAIK,QAAQ,OAAKC,UAAL,CAAgBR,GAAhB,CAAZ;AACA,uBAAKS,IAAL,CAAU,UAAV,EAAsBF,KAAtB;AACH,aAdE,EAeFQ,KAfE,CAeI,eAAG;AACNC,wBAAQC,KAAR,CAAcC,GAAd;AACAC,wBAAQC,IAAR,CAAa,CAAb;AACH,aAlBE,CAAP;AAmBH;;;mCAEUrB,I,EAAYC,G,EAAe;AAAA;;AAClC,gBAAI,CAACA,IAAIqB,IAAT,EAAe;AACXrB,oBAAIqB,IAAJ,GAAW,KAAK7B,OAAhB;AACH;AAED,gBAAIQ,IAAIsB,IAAR,EAAc;AACVN,wBAAQO,GAAR,CAAYlC,MAAMmC,IAAN,CAAW,oBAAX,CAAZ;AACA,qBAAKC,SAAL,CAAezB,IAAIsB,IAAnB;AACH;AAED,gBAAIf,QAAQ,KAAKC,UAAL,CAAgBR,GAAhB,CAAZ;AACA,iBAAKS,IAAL,CAAU,YAAV,EAAwBF,KAAxB;AACA,mBAAO,KAAKmB,SAAL,CAAe3B,IAAf,EAAqB,KAAKN,MAAL,CAAYkC,KAAjC,EAAwCpB,KAAxC,EACFL,IADE,CACG,eAAG;AACL,uBAAKO,IAAL,CAAU,YAAV,EAAwBmB,GAAxB,EAA6BrB,KAA7B;AACA,uBAAOqB,GAAP;AACH,aAJE,EAKFb,KALE,CAKI,eAAG;AACNC,wBAAQC,KAAR,CAAcC,GAAd;AACAC,wBAAQC,IAAR,CAAa,CAAb;AACH,aARE,CAAP;AASH;;;8BAEKrB,I,EAAU;AAAA;;AACZ,gBAAIN,SAAS,KAAKA,MAAlB;AACAA,mBAAOoC,SAAP,GAAmBpC,OAAOoC,SAAP,IAAoB,OAAvC;AACA9B,iBAAKK,IAAL,CAAUX,OAAOoC,SAAjB,EAA4B,UAACC,QAAD,EAAuB;AAC/C,oBAAIC,UAAsB9C,SAASkC,QAAQa,IAAR,CAAaC,KAAb,CAAmB,CAAnB,CAAT,EAAgC;AACtDC,4BAAQ,KAD8C;AAEtDC,6BAAS,EAAEnC,KAAKmB,QAAQnB,GAAR,CAAYoC,QAAZ,IAAwB,aAA/B;AAF6C,iBAAhC,CAA1B;AAIA,uBAAO,OAAKC,GAAL,CAAStC,IAAT,EAAegC,OAAf,CAAP;AACH,aAND;AAQAtC,mBAAO6C,SAAP,GAAmB7C,OAAO6C,SAAP,IAAoB,OAAvC;AACAvC,iBAAKK,IAAL,CAAUX,OAAO6C,SAAjB,EAA4B,UAACR,QAAD,EAAuB;AAC/C,oBAAIC,UAAsB9C,SAASkC,QAAQa,IAAR,CAAaC,KAAb,CAAmB,CAAnB,CAAT,EAAgC;AACtDC,4BAAQ,KAD8C;AAEtDC,6BAAS,EAAEnC,KAAKmB,QAAQnB,GAAR,CAAYoC,QAAZ,IAAwB,aAA/B;AAF6C,iBAAhC,CAA1B;AAIA,oBAAI,CAACL,QAAQ3B,IAAb,EAAmB;AACf,2BAAOmC,QAAQC,MAAR,CAAe,2BAAf,CAAP;AACH;AACD,uBAAO,OAAKH,GAAL,CAAStC,IAAT,EAAegC,OAAf,CAAP;AACH,aATD;AAWAhC,iBAAKK,IAAL,CAAU,SAAV,EAAqB,YAAA;AACjBL,qBAAK0C,KAAL,CAAWhD,OAAOoC,SAAlB;AACH,aAFD;AAGH;;;mCAGU7B,G,EAAG;AACV,gBAAI,CAAC,KAAK0C,SAAN,IAAmB,KAAKA,SAAL,CAAe1C,GAAf,KAAuBA,GAA9C,EAAmD;AAC/C,oBAAI2C,SAAS,KAAKlD,MAAL,CAAYkD,MAAZ,IAAsB,EAAnC;AACA,qBAAKD,SAAL,GAA2B,KAAKjD,MAAL,CAAYmD,cAAZ,CAA2B;AAClD5C,yBAAKA,GAD6C;AAElD2C,4BAAQA;AAF0C,iBAA3B,CAA3B;AAIH;AAED,mBAAO,KAAKD,SAAZ;AACH;;;kCAGmB3C,I,EAAY4B,K,EAAmBkB,M,EAAgB;AAAA;;AAC/D,mBAAON,QAAQO,GAAR,CACH/D,EAAEgE,GAAF,CAAMhE,EAAEiE,OAAF,CAAUrB,KAAV,IAAkCA,KAAlC,GAA0C,CAAcA,KAAd,CAAhD,EAAsE,kBAAM;AACxE;AACA;AACA,oBAAIsB,SAAS,OAAKC,YAAL,CAAkBC,MAAlB,EAA0BN,MAA1B,CAAb;AAEA,uBAAOI,OAAOG,WAAP,CAAmBP,OAAO7C,GAA1B,EACFE,IADE,CACG,eAAG;AACLc,4BAAQO,GAAR,CAAYlC,MAAMgE,KAAN,CAAY,sBAAZ,CAAZ;AACA,wBAAIC,IAAItD,GAAJ,CAAQsB,IAAZ,EAAkB;AACd,4BAAIgC,IAAI7B,SAAR,EAAmB;AACfT,oCAAQO,GAAR,CAAYlC,MAAMmC,IAAN,CAAW,gCAAX,CAAZ;AACA8B,gCAAI7B,SAAJ,CAAc1C,EAAEwE,QAAF,CAAWD,IAAItD,GAAJ,CAAQsB,IAAnB,IAA2BgC,IAAItD,GAAJ,CAAQsB,IAAnC,GAA0C,EAAxD;AACH;AACD,+BAAO,EAAP;AACH,qBAND,MAMO;AACH,+BAAOiB,QAAQO,GAAR,CAAY,CACfG,OAAOO,IAAP,CAAYF,GAAZ,CADe,EAEf,OAAKG,eAAL,CAAqB1D,IAArB,EAA2BuD,GAA3B,CAFe,EAGf,OAAKI,WAAL,CAAiB3D,IAAjB,EAAuBuD,GAAvB,CAHe,CAAZ,EAKFpD,IALE,CAKG,eAAG;AACLc,oCAAQO,GAAR,CAAYlC,MAAMgE,KAAN,CAAY,eAAZ,CAAZ;AACA,mCAAO,OAAKxB,SAAL,CAAe9B,IAAf,EAAqBuD,GAArB,EAA0BK,IAAI,CAAJ,CAA1B,EAAkCA,IAAI,CAAJ,CAAlC,EAA0CA,IAAI,CAAJ,CAA1C,CAAP;AACH,yBARE,CAAP;AASH;AACJ,iBApBE,CAAP;AAqBH,aA1BD,CADG,EA6BFzD,IA7BE,CA6BG,eAAG;AACL,oBAAI0D,MAAa,EAAjB;AACA7E,kBAAEY,IAAF,CAAOiC,GAAP,EAAY,aAAC;AACT,wBAAIiC,KAAK1E,mBAAA2E,WAAA,CAAY/D,IAAZ,EAAkBgE,CAAlB,EAAqBlB,MAArB,CAAT;AACA,wBAAIgB,EAAJ,EAAQ;AACJD,4BAAII,IAAJ,CAASH,EAAT;AACH;AACJ,iBALD;AAMA,uBAAOD,GAAP;AAEH,aAvCE,CAAP;AAwCH;;;kCAEmB7D,I,EAAYuD,G,EAAmB3B,K,EAAgBsC,W,EAAwBC,Y,EAAuB;AAC9G,mBAAO3B,QAAQ4B,OAAR,CAAgBhF,mBAAAiF,UAAA,CAAWrE,IAAX,EAAiB4B,KAAjB,EAAwB2B,GAAxB,CAAhB,EACFpD,IADE,CACG,gBAAI;AACN,oBAAIoD,IAAIe,QAAR,EAAkB;AACd,2BAAOf,IAAIe,QAAJ,CAAaC,IAAb,EAAmBL,WAAnB,EAAgCC,YAAhC,CAAP;AACH;AACD;AACAZ,oBAAIiB,aAAJ,CAAkBD,IAAlB,EAAwBL,WAAxB;AACAX,oBAAIiB,aAAJ,CAAkBD,IAAlB,EAAwBJ,YAAxB;AAEA,uBAAOI,IAAP;AACH,aAVE,CAAP;AAWH;AAED;;;;;;;;;;;;;oCAUsBvE,I,EAAYuD,G,EAAa;AAAA;;AAC3C,gBAAIA,IAAIX,MAAJ,CAAW,OAAX,CAAJ,EAAyB;AAAA;AACrB,wBAAIQ,SAAsBG,IAAIX,MAA9B;AACA5D,sBAAEY,IAAF,CAAOZ,EAAEiE,OAAF,CAAUG,OAAOxB,KAAjB,IAA0BwB,OAAOxB,KAAjC,GAAyC,CAACwB,OAAOxB,KAAR,CAAhD,EAAgE,kBAAM;AAClE6C,+BAAOC,IAAP,GAAcnB,IAAIoB,WAAJ,CAAgBF,OAAOC,IAAvB,CAAd;AACA;AACA;AACH,qBAJD;AAKA;AAAA,2BAAO,OAAK/C,SAAL,CAAe3B,IAAf,EAAqBoD,OAAOxB,KAA5B,EAAmC2B,GAAnC,EACFpD,IADE,CACG,kBAAM;AACR,gCAAIyE,iBAAJ;AACA,gCAAIxB,OAAOyB,aAAP,KAAyBzF,mBAAAwB,MAAA,CAAOC,QAApC,EAA8C;AAC1C+D,2CAAW,CAACxF,mBAAA2B,eAAA,CAAgBf,IAAhB,EAAsB8E,MAAtB,EAA8BvB,GAA9B,EAAmC,UAACmB,IAAD,EAAOK,MAAP;AAAA,2CAAkBxB,IAAIoB,WAAJ,CAAgBD,IAAhB,EAAuBK,WAAW3F,mBAAAwB,MAAA,CAAOoE,QAAlB,GAA6B,OAA7B,GAAuC,OAA9D,CAAlB;AAAA,iCAAnC,CAAD,CAAX;AACH,6BAFD,MAEO;AACHJ,2CAAWxF,mBAAA2E,WAAA,CAAY/D,IAAZ,EAAkB8E,MAAlB,EAA0BvB,GAA1B,EAA+B,UAACmB,IAAD,EAAOK,MAAP;AAAA,2CAAkBxB,IAAIoB,WAAJ,CAAgBD,IAAhB,EAAuBK,WAAW3F,mBAAAwB,MAAA,CAAOoE,QAAlB,GAA6B,OAA7B,GAAuC,OAA9D,CAAlB;AAAA,iCAA/B,CAAX;AACH;AACD,gCAAIJ,QAAJ,EAAc;AACV,uCAAkB;AACdK,2CAAO7B,OAAO8B,YADA;AAEdC,8CAAUP;AAFI,iCAAlB;AAIH,6BALD,MAKO;AACH,uCAAO,IAAP;AACH;AACJ,yBAhBE;AAAP;AAPqB;;AAAA;AAwBxB,aAxBD,MAwBO;AACH,uBAAOpC,QAAQ4B,OAAR,CAAgB,IAAhB,CAAP;AACH;AACJ;AAED;;;;;;;;;;;;;wCAU0BpE,I,EAAYuD,G,EAAa;AAAA;;AAC/C,gBAAIH,SAAwBG,IAAIX,MAAhC;AACA,gBAAIQ,OAAOgC,OAAX,EAAoB;AAAA;AAChB,wBAAIxD,QAAyB,EAA7B;AACA5C,sBAAEY,IAAF,CAAOZ,EAAEa,IAAF,CAAOuD,OAAOgC,OAAd,CAAP,EAA+B,gBAAI;AAC/B,4BAAIC,WAAJ;AACA,4BAAIC,KAAKlC,OAAOgC,OAAP,CAAeV,IAAf,CAAT;AACA,4BAAI1F,EAAEwE,QAAF,CAAW8B,EAAX,CAAJ,EAAoB;AAChBD,iCAAoB,EAAEE,KAAKD,EAAP,EAAWpC,QAAQ,CAAC,EAAEwB,MAAMA,IAAR,EAAcc,OAAO,EAArB,EAAyBC,OAAO,IAAhC,EAAD,CAAnB,EAApB;AACH,yBAFD,MAEO,IAAIzG,EAAE0G,QAAF,CAAWJ,EAAX,CAAJ,EAAoB;AACvB;AACAD,iCAAoB,EAAEnC,QAAQ,CAAC,EAAEyC,MAAML,EAAR,EAAYZ,MAAMA,IAAlB,EAAwBc,OAAO,EAA/B,EAAD,CAAV,EAApB;AACH,yBAHM,MAGA,IAAIxG,EAAE4G,UAAF,CAAaN,EAAb,CAAJ,EAAsB;AACzBD,iCAAK,EAAEnC,QAAQoC,EAAV,EAAL;AACH,yBAFM,MAEA,IAAItG,EAAEiE,OAAF,CAAUqC,EAAV,CAAJ,EAAmB;AACtB,gCAAIA,GAAGO,MAAH,GAAY,CAAhB,EAAmB;AACf,oCAAI7G,EAAEwE,QAAF,CAAWxE,EAAE8G,KAAF,CAAkBR,EAAlB,CAAX,CAAJ,EAAuC;AACnCD,yCAAoB,EAAEE,KAAeD,EAAjB,EAAqBpC,QAAQ,CAAC,EAAEwB,MAAMA,IAAR,EAAcc,OAAO,EAArB,EAAyBC,OAAO,IAAhC,EAAD,CAA7B,EAApB;AACH,iCAFD,MAEO;AACHJ,yCAAoB,EAAEnC,QAA8BoC,EAAhC,EAAoCG,OAAO,IAA3C,EAApB;AACH;AACJ;AACJ,yBARM,MAQA;AACHJ,iCAAKC,EAAL;AACH;AAED,4BAAItG,EAAE+G,MAAF,CAASV,EAAT,KAAgBrG,EAAEgH,WAAF,CAAcX,EAAd,CAApB,EAAuC;AACnC;AACH;AACDA,2BAAGX,IAAH,GAAUW,GAAGX,IAAH,IAAWnB,IAAIoB,WAAJ,CAAgBD,IAAhB,CAArB;AACAW,2BAAGE,GAAH,GAASF,GAAGE,GAAH,IAAWhC,IAAI0C,MAAJ,CAAW,EAAEN,MAAMvG,mBAAA8G,SAAA,CAAUC,KAAlB,EAAX,IAAwC,QAAxC,GAAmDzB,IAAvE;AACA;AACA9C,8BAAMqC,IAAN,CAAWoB,EAAX;AACH,qBA7BD;AA+BA;AAAA,2BAAO7C,QAAQO,GAAR,CAAY/D,EAAEgE,GAAF,CAAMpB,KAAN,EAAa,gBAAI;AAChC,mCAAO,OAAKD,SAAL,CAAe3B,IAAf,EAAkCK,IAAlC,EAAwCkD,GAAxC,EACFpD,IADE,CACG,cAAE;AACJ,uCAAO;AACHE,0CAAMA,IADH;AAEH+F,wCAAIA;AAFD,iCAAP;AAIH,6BANE,CAAP;AAOH,yBARkB,CAAZ,EASFjG,IATE,CASG,gBAAI;AACN;AACA,gCAAIkG,YAAYrH,EAAEgE,GAAF,CAAM5C,IAAN,EAAY,aAAC;AACzB,uCAAOhB,mBAAA2E,WAAA,CAAY/D,IAAZ,EAAkBgE,EAAEoC,EAApB,EAAwB7C,GAAxB,EAA6B,UAACmB,IAAD,EAAOK,MAAP;AAAA,2CAAkBxB,IAAIoB,WAAJ,CAAgBX,EAAE3D,IAAF,CAAOqE,IAAvB,EAA6BK,WAAW3F,mBAAAwB,MAAA,CAAOoE,QAAlB,GAA6B,UAA7B,GAA0C,UAAvE,CAAlB;AAAA,iCAA7B,CAAP,CADyB,CACkH;AAC9I,6BAFe,CAAhB;AAIA,gCAAIJ,iBAAJ;AACA,gCAAIxB,OAAOkD,aAAP,KAAyBlH,mBAAAwB,MAAA,CAAOoE,QAApC,EAA8C;AAC1CJ,2CAAWyB,SAAX;AACH,6BAFD,MAEO;AACHzB,2CAAWxF,mBAAA2E,WAAA,CAAY/D,IAAZ,EAAkB,CAACqG,SAAD,CAAlB,EAA+B9C,GAA/B,EAAoC,UAACmB,IAAD,EAAOK,MAAP;AAAA,2CAAkBL,QAAQK,WAAW3F,mBAAAwB,MAAA,CAAOoE,QAAlB,GAA6B,UAA7B,GAA0C,UAAlD,CAAlB;AAAA,iCAApC,CAAX;AACH;AAED,mCAAkB;AACdC,uCAAO7B,OAAOmD,YADA;AAEdpB,0CAAUP;AAFI,6BAAlB;AAIH,yBA1BE;AAAP;AAjCgB;;AAAA;AA4DnB,aA5DD,MA4DO;AACH,uBAAOpC,QAAQ4B,OAAR,CAAgB,IAAhB,CAAP;AACH;AACJ;;;qCAEsBxB,M,EAAoBE,M,EAAgB;AAAA;;AACvD,gBAAI,CAAC9D,EAAE4G,UAAF,CAAa,KAAKlG,MAAL,CAAY8G,aAAzB,CAAL,EAA8C;AAC1C,oBAAIC,UAAU,IAAItH,gBAAAuH,aAAJ,EAAd;AACA,uBAAOD,QAAQE,MAAR,CAAe/D,MAAf,EAAuBE,OAAO7C,GAA9B,EAAmC,UAAC2G,GAAD,EAAMC,CAAN,EAAO;AAC7C,2BAAO,OAAKnH,MAAL,CAAYmD,cAAZ,CAA2B+D,GAA3B,EAAgCC,KAAK/D,MAArC,CAAP;AACH,iBAFM,CAAP;AAGH,aALD,MAKO;AACH,uBAAO,KAAKpD,MAAL,CAAY8G,aAAZ,CAA0B5D,MAA1B,EAAkCE,OAAO7C,GAAzC,CAAP;AACH;AACJ;;;kCAGmBsB,I,EAAsB;AACtC,gBAAIA,SAAS,IAAb,EAAmB;AAEfN,wBAAQO,GAAR;AAeH,aAjBD,MAiBO;AAEHP,wBAAQO,GAAR;AAeH;AACJ;;;+BAjWaxB,I,EAAYP,O,EAAiBqH,O,EAA+K;AAAA,gBAA7FnG,MAA6F,uEAApFvB,mBAAAwB,MAAA,CAAOoE,QAA6E;AAAA,gBAAnEyB,OAAmE;;AACtN,gBAAI7D,SAAS5D,EAAEiE,OAAF,CAAU6D,OAAV,IAAqB,EAAElF,OAAOkF,OAAT,EAAkBnG,QAAQA,MAA1B,EAArB,GAA0DmG,OAAvE;AACA,gBAAI,CAAC9H,EAAEgH,WAAF,CAAcpD,OAAOjC,MAArB,CAAL,EAAmC;AAC/BiC,uBAAOjC,MAAP,GAAgBA,MAAhB;AACH;AACDiC,mBAAOC,cAAP,GAAwB4D,WAAY,UAACG,GAAD,EAAM9D,MAAN,EAAa;AAC7C,oBAAIS,MAAM,IAAIlE,UAAA0H,OAAJ,CAAYH,GAAZ,EAAiB9D,MAAjB,CAAV;AACA,oBAAIA,UAAUA,OAAO,KAAP,CAAd,EAA6B;AACdA,2BAAQkE,GAAR,CAAYzD,GAAZ;AACd;AACD,uBAAOA,GAAP;AACH,aAND;AAQA,gBAAI0D,UAAU,IAAIzH,WAAJ,CAAgBC,OAAhB,EAAyBmD,MAAzB,CAAd;AACAqE,oBAAQC,KAAR,CAAclH,IAAd;AACA,mBAAOiH,OAAP;AACH;;;;EA9B4B1H,SAAA4H,Y;;AAApBC,QAAA5H,WAAA,GAAWA,WAAX","file":"../Development.js","sourcesContent":["\"use strict\";\nconst _ = require('lodash');\nconst minimist = require('minimist');\nconst LoaderFactory_1 = require('./LoaderFactory');\nconst development_core_1 = require('development-core');\nconst Context_1 = require('./Context');\nconst chalk = require('chalk');\nconst events_1 = require('events');\nclass Development extends events_1.EventEmitter {\n    /**\n     * Creates an instance of Development.\n     *\n     * @param {string} dirname\n     * @param {DevelopConfig} config\n     *\n     * @memberOf Development\n     */\n    constructor(dirname, config) {\n        super();\n        this.dirname = dirname;\n        this.config = config;\n        if (config.evnets) {\n            _.each(_.keys(config.evnets), key => {\n                this.on(key, config.evnets[key]);\n            });\n        }\n    }\n    /**\n     * create development tool.\n     *\n     * @static\n     * @param {Gulp} gulp\n     * @param {string} dirname\n     * @param {(DevelopConfig | Array<ITaskOption | IAssertOption | IDynamicTaskOption>)} setting\n     * @param {any} [runWay=RunWay.sequence]\n     * @returns {Development}\n     *\n     * @memberOf Development\n     */\n    static create(gulp, dirname, setting, runWay = development_core_1.RunWay.sequence, factory) {\n        let option = _.isArray(setting) ? { tasks: setting, runWay: runWay } : setting;\n        if (!_.isUndefined(option.runWay)) {\n            option.runWay = runWay;\n        }\n        option.contextFactory = factory || ((cfg, parent) => {\n            let ctx = new Context_1.Context(cfg, parent);\n            if (parent && parent['add']) {\n                parent.add(ctx);\n            }\n            return ctx;\n        });\n        let devtool = new Development(dirname, option);\n        devtool.setup(gulp);\n        return devtool;\n    }\n    /**\n     * run task.\n     *\n     * @param {Gulp} gulp\n     * @param {IEnvOption} env\n     * @returns {Promise<any>}\n     *\n     * @memberOf Development\n     */\n    run(gulp, env) {\n        return this.setupTasks(gulp, env)\n            .then(seq => {\n            let tseq = env.task ? env.task.split(',') : seq;\n            let gbctx = this.getContext(env);\n            this.emit('beforRun', tseq, gbctx);\n            if (this.config.runWay === development_core_1.RunWay.parallel) {\n                return development_core_1.runSequence(gulp, [development_core_1.flattenSequence(gulp, tseq, gbctx)]);\n            }\n            else {\n                return development_core_1.runSequence(gulp, tseq);\n            }\n        })\n            .then(() => {\n            let gbctx = this.getContext(env);\n            this.emit('afterRun', gbctx);\n        })\n            .catch(err => {\n            console.error(err);\n            process.exit(1);\n        });\n    }\n    setupTasks(gulp, env) {\n        if (!env.root) {\n            env.root = this.dirname;\n        }\n        if (env.help) {\n            console.log(chalk.grey('... main help  ...'));\n            this.printHelp(env.help);\n        }\n        let gbctx = this.getContext(env);\n        this.emit('beforSetup', gbctx);\n        return this.loadTasks(gulp, this.config.tasks, gbctx)\n            .then(tsq => {\n            this.emit('afterSetup', tsq, gbctx);\n            return tsq;\n        })\n            .catch(err => {\n            console.error(err);\n            process.exit(1);\n        });\n    }\n    setup(gulp) {\n        let config = this.config;\n        config.setupTask = config.setupTask || 'build';\n        gulp.task(config.setupTask, (callback) => {\n            var options = minimist(process.argv.slice(2), {\n                string: 'env',\n                default: { env: process.env.NODE_ENV || 'development' }\n            });\n            return this.run(gulp, options);\n        });\n        config.startTask = config.startTask || 'start';\n        gulp.task(config.startTask, (callback) => {\n            var options = minimist(process.argv.slice(2), {\n                string: 'env',\n                default: { env: process.env.NODE_ENV || 'development' }\n            });\n            if (!options.task) {\n                return Promise.reject('start task can not empty!');\n            }\n            return this.run(gulp, options);\n        });\n        gulp.task('default', () => {\n            gulp.start(config.setupTask);\n        });\n    }\n    getContext(env) {\n        if (!this.globalctx || this.globalctx.env !== env) {\n            let option = this.config.option || {};\n            this.globalctx = this.config.contextFactory({\n                env: env,\n                option: option\n            });\n        }\n        return this.globalctx;\n    }\n    loadTasks(gulp, tasks, parent) {\n        return Promise.all(_.map(_.isArray(tasks) ? tasks : [tasks], optask => {\n            // optask.dist = optask.dist || 'dist';\n            // console.log(chalk.grey('begin load task via loader:'), optask.loader);\n            let loader = this.createLoader(optask, parent);\n            return loader.loadContext(parent.env)\n                .then(ctx => {\n                console.log(chalk.green('task context loaded.'));\n                if (ctx.env.help) {\n                    if (ctx.printHelp) {\n                        console.log(chalk.grey('...development default help...'));\n                        ctx.printHelp(_.isString(ctx.env.help) ? ctx.env.help : '');\n                    }\n                    return [];\n                }\n                else {\n                    return Promise.all([\n                        loader.load(ctx),\n                        this.loadAssertTasks(gulp, ctx),\n                        this.loadSubTask(gulp, ctx)\n                    ])\n                        .then(tks => {\n                        console.log(chalk.green('tasks loaded.'));\n                        return this.setupTask(gulp, ctx, tks[0], tks[1], tks[2]);\n                    });\n                }\n            });\n        }))\n            .then(tsq => {\n            let rst = [];\n            _.each(tsq, t => {\n                let tk = development_core_1.zipSequence(gulp, t, parent);\n                if (tk) {\n                    rst.push(tk);\n                }\n            });\n            return rst;\n        });\n    }\n    setupTask(gulp, ctx, tasks, assertsTask, subGroupTask) {\n        return Promise.resolve(development_core_1.toSequence(gulp, tasks, ctx))\n            .then(tsqs => {\n            if (ctx.runTasks) {\n                return ctx.runTasks(tsqs, assertsTask, subGroupTask);\n            }\n            // console.log(assertsTask);\n            ctx.addToSequence(tsqs, assertsTask);\n            ctx.addToSequence(tsqs, subGroupTask);\n            return tsqs;\n        });\n    }\n    /**\n     * load sub tasks as group task.\n     *\n     * @protected\n     * @param {Gulp} gulp\n     * @param {IContext} ctx\n     * @returns {Promise<ITaskInfo>}\n     *\n     * @memberOf Development\n     */\n    loadSubTask(gulp, ctx) {\n        if (ctx.option['tasks']) {\n            let optask = ctx.option;\n            _.each(_.isArray(optask.tasks) ? optask.tasks : [optask.tasks], subopt => {\n                subopt.name = ctx.subTaskName(subopt.name);\n                // subopt.src = subopt.src || optask.src;\n                // subopt.dist = subopt.dist || optask.dist;\n            });\n            return this.loadTasks(gulp, optask.tasks, ctx)\n                .then(subseq => {\n                let taskname;\n                if (optask.subTaskRunWay === development_core_1.RunWay.parallel) {\n                    taskname = [development_core_1.flattenSequence(gulp, subseq, ctx, (name, runway) => ctx.subTaskName(name, (runway === development_core_1.RunWay.sequence ? '-subs' : '-subp')))];\n                }\n                else {\n                    taskname = development_core_1.zipSequence(gulp, subseq, ctx, (name, runway) => ctx.subTaskName(name, (runway === development_core_1.RunWay.sequence ? '-subs' : '-subp')));\n                }\n                if (taskname) {\n                    return {\n                        order: optask.subTaskOrder,\n                        taskName: taskname\n                    };\n                }\n                else {\n                    return null;\n                }\n            });\n        }\n        else {\n            return Promise.resolve(null);\n        }\n    }\n    /**\n     * load asserts tasks.\n     *\n     * @protected\n     * @param {Gulp} gulp\n     * @param {ITaskContext} ctx\n     * @returns {Promise<Src>}\n     *\n     * @memberOf Development\n     */\n    loadAssertTasks(gulp, ctx) {\n        let optask = ctx.option;\n        if (optask.asserts) {\n            let tasks = [];\n            _.each(_.keys(optask.asserts), name => {\n                let op;\n                let sr = optask.asserts[name];\n                if (_.isString(sr)) {\n                    op = { src: sr, loader: [{ name: name, pipes: [], watch: true }] };\n                }\n                else if (_.isNumber(sr)) {\n                    // watch with Operation.autoWatch.\n                    op = { loader: [{ oper: sr, name: name, pipes: [] }] };\n                }\n                else if (_.isFunction(sr)) {\n                    op = { loader: sr };\n                }\n                else if (_.isArray(sr)) {\n                    if (sr.length > 0) {\n                        if (_.isString(_.first(sr))) {\n                            op = { src: sr, loader: [{ name: name, pipes: [], watch: true }] };\n                        }\n                        else {\n                            op = { loader: sr, watch: true };\n                        }\n                    }\n                }\n                else {\n                    op = sr;\n                }\n                if (_.isNull(op) || _.isUndefined(op)) {\n                    return;\n                }\n                op.name = op.name || ctx.subTaskName(name);\n                op.src = op.src || (ctx.getSrc({ oper: development_core_1.Operation.build }) + '/**/*.' + name);\n                // op.dist = op.dist || ctx.getDist({ oper: Operation.build });\n                tasks.push(op);\n            });\n            return Promise.all(_.map(tasks, task => {\n                return this.loadTasks(gulp, task, ctx)\n                    .then(sq => {\n                    return {\n                        task: task,\n                        sq: sq\n                    };\n                });\n            }))\n                .then(tseq => {\n                // asserts tasks run mutil.\n                let assertSeq = _.map(tseq, t => {\n                    return development_core_1.zipSequence(gulp, t.sq, ctx, (name, runway) => ctx.subTaskName(t.task.name, runway === development_core_1.RunWay.sequence ? '-asserts' : '-assertp')); // ctx.subTaskName(name + (runway === RunWay.sequence ? '-assert-seq' : '-assert-par')));\n                });\n                let taskname;\n                if (optask.assertsRunWay === development_core_1.RunWay.sequence) {\n                    taskname = assertSeq;\n                }\n                else {\n                    taskname = development_core_1.zipSequence(gulp, [assertSeq], ctx, (name, runway) => name + (runway === development_core_1.RunWay.sequence ? '-asserts' : '-assertp'));\n                }\n                return {\n                    order: optask.assertsOrder,\n                    taskName: taskname\n                };\n            });\n        }\n        else {\n            return Promise.resolve(null);\n        }\n    }\n    createLoader(option, parent) {\n        if (!_.isFunction(this.config.loaderFactory)) {\n            let factory = new LoaderFactory_1.LoaderFactory();\n            return factory.create(option, parent.env, (cfg, p) => {\n                return this.config.contextFactory(cfg, p || parent);\n            });\n        }\n        else {\n            return this.config.loaderFactory(option, parent.env);\n        }\n    }\n    printHelp(help) {\n        if (help === 'en') {\n            console.log(`\r\n                /**\r\n                 * gulp [build] [--env production|development] [--context name] [--root path] [--watch] [--test] [--serve] [--release] [--task taskname]\r\n                 * @params\r\n                 *  --env  development or production;\r\n                 *  --context app setting\r\n                 *  --root path, set relative path of the development tool root.\r\n                 *  --watch  watch src file change or not. if changed will auto update to node service. \r\n                 *  --release release web app or not. if [--env production], default to release. \r\n                 *  --test  need auto load test file to node service.\r\n                 *  --deploy run deploy tasks to deploy project.  \r\n                 *  --serve start node web service or not.\r\n                 *  --task taskname  spruce task taskname\r\n                 **/`);\n        }\n        else {\n            console.log(`\r\n                /**\r\n                 * gulp [build] [--env production|development] [--context name] [--root path] [--watch] [--test] [--serve] [--release] [--task taskname]\r\n                 * @params\r\n                 *  --env 发布环境 默认开发环境development;\r\n                 *  --context 设置配置文件;\r\n                 *  --root path, 设置编译环境相对路径\r\n                 *  --watch  是否需要动态监听文件变化\r\n                 *  --release 是否release编译, [--env production] 默认release \r\n                 *  --test  启动自动化测试\r\n                 *  --deploy 运行加载deploy tasks, 编译发布项目。  \r\n                 *  --serve  是否在开发模式下 开启node web服务\r\n                 *  --task taskname  运行单独任务taskname\r\n                 **/`);\n        }\n    }\n}\nexports.Development = Development;\n","import * as _ from 'lodash';\r\nimport { Gulp, TaskCallback } from 'gulp';\r\n\r\nimport * as minimist from 'minimist';\r\nimport { ITaskLoader } from './ITaskLoader';\r\nimport { LoaderFactory } from './LoaderFactory';\r\nimport { Operation, ITaskConfig, Src, toSequence, runSequence, bindingConfig, zipSequence, flattenSequence, ITaskContext, ITaskInfo, ITask, IEnvOption, IDynamicTaskOption, RunWay } from 'development-core';\r\nimport { TaskOption, ITaskOption, IAssertOption } from './TaskOption';\r\nimport { IContext } from './IContext';\r\nimport { Context } from './Context';\r\nimport { DevelopConfig } from './DevelopConfig';\r\nimport * as chalk from 'chalk';\r\nimport { EventEmitter } from 'events';\r\n\r\nexport class Development extends EventEmitter {\r\n\r\n    /**\r\n     * create development tool.\r\n     * \r\n     * @static\r\n     * @param {Gulp} gulp\r\n     * @param {string} dirname\r\n     * @param {(DevelopConfig | Array<ITaskOption | IAssertOption | IDynamicTaskOption>)} setting\r\n     * @param {any} [runWay=RunWay.sequence]\r\n     * @returns {Development}\r\n     * \r\n     * @memberOf Development\r\n     */\r\n    static create(gulp: Gulp, dirname: string, setting: DevelopConfig | Array<ITaskOption | IAssertOption | IDynamicTaskOption>, runWay = RunWay.sequence, factory?: (cfg: ITaskConfig, parent?: ITaskContext) => ITaskContext): Development {\r\n        let option = _.isArray(setting) ? { tasks: setting, runWay: runWay } : setting;\r\n        if (!_.isUndefined(option.runWay)) {\r\n            option.runWay = runWay;\r\n        }\r\n        option.contextFactory = factory || ((cfg, parent?) => {\r\n            let ctx = new Context(cfg, parent);\r\n            if (parent && parent['add']) {\r\n                (<IContext>parent).add(ctx);\r\n            }\r\n            return ctx;\r\n        })\r\n\r\n        let devtool = new Development(dirname, option);\r\n        devtool.setup(gulp);\r\n        return devtool;\r\n    }\r\n\r\n    /**\r\n     * Creates an instance of Development.\r\n     * \r\n     * @param {string} dirname\r\n     * @param {DevelopConfig} config\r\n     * \r\n     * @memberOf Development\r\n     */\r\n    public constructor(private dirname: string, protected config: DevelopConfig) {\r\n        super();\r\n        if (config.evnets) {\r\n            _.each(_.keys(config.evnets), key => {\r\n                this.on(key, config.evnets[key]);\r\n            });\r\n        }\r\n    }\r\n\r\n    /**\r\n     * run task.\r\n     * \r\n     * @param {Gulp} gulp\r\n     * @param {IEnvOption} env\r\n     * @returns {Promise<any>}\r\n     * \r\n     * @memberOf Development\r\n     */\r\n    run(gulp: Gulp, env: IEnvOption): Promise<any> {\r\n        return this.setupTasks(gulp, env)\r\n            .then(seq => {\r\n                let tseq = env.task ? env.task.split(',') : seq;\r\n                let gbctx = this.getContext(env);\r\n                this.emit('beforRun', tseq, gbctx);\r\n                if (this.config.runWay === RunWay.parallel) {\r\n                    return runSequence(gulp, [flattenSequence(gulp, tseq, gbctx)]);\r\n                } else {\r\n                    return runSequence(gulp, tseq);\r\n                }\r\n            })\r\n            .then(() => {\r\n                let gbctx = this.getContext(env);\r\n                this.emit('afterRun', gbctx);\r\n            })\r\n            .catch(err => {\r\n                console.error(err);\r\n                process.exit(1);\r\n            });\r\n    }\r\n\r\n    setupTasks(gulp: Gulp, env: IEnvOption): Promise<Src[]> {\r\n        if (!env.root) {\r\n            env.root = this.dirname;\r\n        }\r\n\r\n        if (env.help) {\r\n            console.log(chalk.grey('... main help  ...'));\r\n            this.printHelp(env.help);\r\n        }\r\n\r\n        let gbctx = this.getContext(env);\r\n        this.emit('beforSetup', gbctx);\r\n        return this.loadTasks(gulp, this.config.tasks, gbctx)\r\n            .then(tsq => {\r\n                this.emit('afterSetup', tsq, gbctx);\r\n                return tsq;\r\n            })\r\n            .catch(err => {\r\n                console.error(err);\r\n                process.exit(1);\r\n            });\r\n    }\r\n\r\n    setup(gulp: Gulp) {\r\n        let config = this.config;\r\n        config.setupTask = config.setupTask || 'build';\r\n        gulp.task(config.setupTask, (callback: TaskCallback) => {\r\n            var options: IEnvOption = minimist(process.argv.slice(2), {\r\n                string: 'env',\r\n                default: { env: process.env.NODE_ENV || 'development' }\r\n            });\r\n            return this.run(gulp, options);\r\n        });\r\n\r\n        config.startTask = config.startTask || 'start';\r\n        gulp.task(config.startTask, (callback: TaskCallback) => {\r\n            var options: IEnvOption = minimist(process.argv.slice(2), {\r\n                string: 'env',\r\n                default: { env: process.env.NODE_ENV || 'development' }\r\n            });\r\n            if (!options.task) {\r\n                return Promise.reject('start task can not empty!');\r\n            }\r\n            return this.run(gulp, options);\r\n        })\r\n\r\n        gulp.task('default', () => {\r\n            gulp.start(config.setupTask);\r\n        });\r\n    }\r\n\r\n    private globalctx: IContext;\r\n    getContext(env) {\r\n        if (!this.globalctx || this.globalctx.env !== env) {\r\n            let option = this.config.option || {};\r\n            this.globalctx = <IContext>this.config.contextFactory({\r\n                env: env,\r\n                option: option\r\n            });\r\n        }\r\n\r\n        return this.globalctx;\r\n    }\r\n\r\n\r\n    protected loadTasks(gulp: Gulp, tasks: TaskOption, parent: IContext): Promise<Src[]> {\r\n        return Promise.all<Src[]>(\r\n            _.map(_.isArray(tasks) ? <ITaskOption[]>tasks : [<ITaskOption>tasks], optask => {\r\n                // optask.dist = optask.dist || 'dist';\r\n                // console.log(chalk.grey('begin load task via loader:'), optask.loader);\r\n                let loader = this.createLoader(optask, parent);\r\n\r\n                return loader.loadContext(parent.env)\r\n                    .then(ctx => {\r\n                        console.log(chalk.green('task context loaded.'));\r\n                        if (ctx.env.help) {\r\n                            if (ctx.printHelp) {\r\n                                console.log(chalk.grey('...development default help...'));\r\n                                ctx.printHelp(_.isString(ctx.env.help) ? ctx.env.help : '');\r\n                            }\r\n                            return [];\r\n                        } else {\r\n                            return Promise.all([\r\n                                loader.load(ctx),\r\n                                this.loadAssertTasks(gulp, ctx),\r\n                                this.loadSubTask(gulp, ctx)\r\n                            ])\r\n                                .then(tks => {\r\n                                    console.log(chalk.green('tasks loaded.'));\r\n                                    return this.setupTask(gulp, ctx, tks[0], tks[1], tks[2]);\r\n                                });\r\n                        }\r\n                    });\r\n            })\r\n        )\r\n            .then(tsq => {\r\n                let rst: Src[] = [];\r\n                _.each(tsq, t => {\r\n                    let tk = zipSequence(gulp, t, parent);\r\n                    if (tk) {\r\n                        rst.push(tk);\r\n                    }\r\n                });\r\n                return rst;\r\n\r\n            });\r\n    }\r\n\r\n    protected setupTask(gulp: Gulp, ctx: ITaskContext, tasks: ITask[], assertsTask: ITaskInfo, subGroupTask: ITaskInfo): Promise<Src[]> {\r\n        return Promise.resolve(toSequence(gulp, tasks, ctx))\r\n            .then(tsqs => {\r\n                if (ctx.runTasks) {\r\n                    return ctx.runTasks(tsqs, assertsTask, subGroupTask);\r\n                }\r\n                // console.log(assertsTask);\r\n                ctx.addToSequence(tsqs, assertsTask);\r\n                ctx.addToSequence(tsqs, subGroupTask);\r\n\r\n                return tsqs;\r\n            });\r\n    }\r\n\r\n    /**\r\n     * load sub tasks as group task.\r\n     * \r\n     * @protected\r\n     * @param {Gulp} gulp\r\n     * @param {IContext} ctx\r\n     * @returns {Promise<ITaskInfo>}\r\n     * \r\n     * @memberOf Development\r\n     */\r\n    protected loadSubTask(gulp: Gulp, ctx: IContext): Promise<ITaskInfo> {\r\n        if (ctx.option['tasks']) {\r\n            let optask = <ITaskOption>ctx.option;\r\n            _.each(_.isArray(optask.tasks) ? optask.tasks : [optask.tasks], subopt => {\r\n                subopt.name = ctx.subTaskName(subopt.name);\r\n                // subopt.src = subopt.src || optask.src;\r\n                // subopt.dist = subopt.dist || optask.dist;\r\n            });\r\n            return this.loadTasks(gulp, optask.tasks, ctx)\r\n                .then(subseq => {\r\n                    let taskname;\r\n                    if (optask.subTaskRunWay === RunWay.parallel) {\r\n                        taskname = [flattenSequence(gulp, subseq, ctx, (name, runway) => ctx.subTaskName(name, (runway === RunWay.sequence ? '-subs' : '-subp')))]\r\n                    } else {\r\n                        taskname = zipSequence(gulp, subseq, ctx, (name, runway) => ctx.subTaskName(name, (runway === RunWay.sequence ? '-subs' : '-subp')));\r\n                    }\r\n                    if (taskname) {\r\n                        return <ITaskInfo>{\r\n                            order: optask.subTaskOrder,\r\n                            taskName: taskname\r\n                        };\r\n                    } else {\r\n                        return null;\r\n                    }\r\n                });\r\n        } else {\r\n            return Promise.resolve(null);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * load asserts tasks.\r\n     * \r\n     * @protected\r\n     * @param {Gulp} gulp\r\n     * @param {ITaskContext} ctx\r\n     * @returns {Promise<Src>}\r\n     * \r\n     * @memberOf Development\r\n     */\r\n    protected loadAssertTasks(gulp: Gulp, ctx: IContext): Promise<ITaskInfo> {\r\n        let optask = <IAssertOption>ctx.option;\r\n        if (optask.asserts) {\r\n            let tasks: IAssertOption[] = [];\r\n            _.each(_.keys(optask.asserts), name => {\r\n                let op: IAssertOption;\r\n                let sr = optask.asserts[name];\r\n                if (_.isString(sr)) {\r\n                    op = <IAssertOption>{ src: sr, loader: [{ name: name, pipes: [], watch: true }] };\r\n                } else if (_.isNumber(sr)) {\r\n                    // watch with Operation.autoWatch.\r\n                    op = <IAssertOption>{ loader: [{ oper: sr, name: name, pipes: [] }] };\r\n                } else if (_.isFunction(sr)) {\r\n                    op = { loader: sr };\r\n                } else if (_.isArray(sr)) {\r\n                    if (sr.length > 0) {\r\n                        if (_.isString(_.first(<string[]>sr))) {\r\n                            op = <IAssertOption>{ src: <string[]>sr, loader: [{ name: name, pipes: [], watch: true }] };\r\n                        } else {\r\n                            op = <IAssertOption>{ loader: <IDynamicTaskOption[]>sr, watch: true };\r\n                        }\r\n                    }\r\n                } else {\r\n                    op = sr;\r\n                }\r\n\r\n                if (_.isNull(op) || _.isUndefined(op)) {\r\n                    return;\r\n                }\r\n                op.name = op.name || ctx.subTaskName(name);\r\n                op.src = op.src || (ctx.getSrc({ oper: Operation.build }) + '/**/*.' + name);\r\n                // op.dist = op.dist || ctx.getDist({ oper: Operation.build });\r\n                tasks.push(op);\r\n            });\r\n\r\n            return Promise.all(_.map(tasks, task => {\r\n                return this.loadTasks(gulp, <ITaskOption>task, ctx)\r\n                    .then(sq => {\r\n                        return {\r\n                            task: task,\r\n                            sq: sq\r\n                        }\r\n                    });\r\n            }))\r\n                .then(tseq => {\r\n                    // asserts tasks run mutil.\r\n                    let assertSeq = _.map(tseq, t => {\r\n                        return zipSequence(gulp, t.sq, ctx, (name, runway) => ctx.subTaskName(t.task.name, runway === RunWay.sequence ? '-asserts' : '-assertp')); // ctx.subTaskName(name + (runway === RunWay.sequence ? '-assert-seq' : '-assert-par')));\r\n                    });\r\n\r\n                    let taskname;\r\n                    if (optask.assertsRunWay === RunWay.sequence) {\r\n                        taskname = assertSeq;\r\n                    } else {\r\n                        taskname = zipSequence(gulp, [assertSeq], ctx, (name, runway) => name + (runway === RunWay.sequence ? '-asserts' : '-assertp'));\r\n                    }\r\n\r\n                    return <ITaskInfo>{\r\n                        order: optask.assertsOrder,\r\n                        taskName: taskname\r\n                    }\r\n                });\r\n        } else {\r\n            return Promise.resolve(null);\r\n        }\r\n    }\r\n\r\n    protected createLoader(option: TaskOption, parent: IContext): ITaskLoader {\r\n        if (!_.isFunction(this.config.loaderFactory)) {\r\n            let factory = new LoaderFactory();\r\n            return factory.create(option, parent.env, (cfg, p) => {\r\n                return this.config.contextFactory(cfg, p || parent);\r\n            });\r\n        } else {\r\n            return this.config.loaderFactory(option, parent.env);\r\n        }\r\n    }\r\n\r\n\r\n    protected printHelp(help: boolean | string) {\r\n        if (help === 'en') {\r\n\r\n            console.log(`\r\n                /**\r\n                 * gulp [build] [--env production|development] [--context name] [--root path] [--watch] [--test] [--serve] [--release] [--task taskname]\r\n                 * @params\r\n                 *  --env  development or production;\r\n                 *  --context app setting\r\n                 *  --root path, set relative path of the development tool root.\r\n                 *  --watch  watch src file change or not. if changed will auto update to node service. \r\n                 *  --release release web app or not. if [--env production], default to release. \r\n                 *  --test  need auto load test file to node service.\r\n                 *  --deploy run deploy tasks to deploy project.  \r\n                 *  --serve start node web service or not.\r\n                 *  --task taskname  spruce task taskname\r\n                 **/`);\r\n\r\n        } else {\r\n\r\n            console.log(`\r\n                /**\r\n                 * gulp [build] [--env production|development] [--context name] [--root path] [--watch] [--test] [--serve] [--release] [--task taskname]\r\n                 * @params\r\n                 *  --env 发布环境 默认开发环境development;\r\n                 *  --context 设置配置文件;\r\n                 *  --root path, 设置编译环境相对路径\r\n                 *  --watch  是否需要动态监听文件变化\r\n                 *  --release 是否release编译, [--env production] 默认release \r\n                 *  --test  启动自动化测试\r\n                 *  --deploy 运行加载deploy tasks, 编译发布项目。  \r\n                 *  --serve  是否在开发模式下 开启node web服务\r\n                 *  --task taskname  运行单独任务taskname\r\n                 **/`);\r\n\r\n        }\r\n    }\r\n}\r\n"]}